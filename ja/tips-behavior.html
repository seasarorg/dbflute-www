<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- don't edit start -->
<head>
<title>Seasar - DI Container with AOP - </title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<link href="seasar_b.css" type="text/css" rel="stylesheet" media="screen" />
<link href="seasar_p.css" type="text/css" rel="stylesheet" media="print" />
<script src="seasar_b.js" type="text/JavaScript" language="JavaScript"></script>
</head>
<body onload="preload('ja')">
<table width="100%" border="0" cellspacing="0" cellpadding="0" align="left"><tr>
<td align="left" valign="top" width="780"><table width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr><td colspan="7"><img height="5" width="780" src="images/top01_b.gif" alt=""></td></tr>
<tr><td><img height="117" width="235" src="images/top02_b.gif" alt="Seasar"></td>
<td colspan="3"><img height="117" width="289" src="images/top03.gif" alt="DI Container with AOP"></td>
<td colspan="3"><img height="117" width="256" src="images/spacer.gif" alt=""></td>
</tr><tr><td rowspan="2"><img src="images/top04.gif" alt="" height="49" width="235"></td>
<td><a href="http://www.seasar.org/index.html"><img src="images/menu01_b_ja.gif" height="30" width="78" border="0" alt="" id="menu01" onmouseover="swap(1)" onmouseout="restore(1)"></a></td>
<td><a href="http://www.seasar.org/projects.html"><img src="images/menu02_b_ja.gif" height="30" width="101" border="0" alt="" id="menu02" onmouseover="swap(2)" onmouseout="restore(2)"></a></td>
<td><a href="http://www.seasar.org/products.html"><img src="images/menu03_b_ja.gif" height="30" width="110" border="0" alt="" id="menu03" onmouseover="swap(3)" onmouseout="restore(3)"></a></td>
<td><a href="http://www.seasar.org/resources.html"><img src="images/menu04_b_ja.gif" height="30" width="113" border="0" alt="" id="menu04" onmouseover="swap(4)" onmouseout="restore(4)"></a></td>
<td><img src="images/menu05_b_ja.gif" height="30" width="109" border="0" alt="" id="menu05" onmouseover="swap(5)" onmouseout="restore(5)"></td>
<td><img height="30" width="34" src="images/menu06.gif" alt=""></td></tr><tr>
<td colspan="6"><img height="19" width="545" src="images/spacer.gif" alt=""></td></tr></table>
<table  width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr align="left" valign="top"><td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td><td width="740" class="main">
<!-- don't edit end -->
<!-- document start -->
<p>
<a href="index.html">to Top</a>
<p><b>
Behaviorについて記述します。
<p></b>
<pre>


// ======================================================================================================
//                                                                                               Behavior
//                                                                                               ========

# ----------------------------------------------------------
#                                          What is behavior?
#                                          -----------------

Behaviorとは

  <b>「DaoとEntityの定番処理を行うObject」</b>

  名前の由来は？ → <b>Daoの振舞い</b> (The behavior of dao)
  その役割は？   → <b>Data-HandlingのFacade</b> (The facade of data handling)


S2DaoのDaoは実質的にSQLの実行しかできませんが、実際の業務アプリでは、
<b>“整合性Check”</b>や<b>“Paging処理”</b>などの<b>Dataを扱った定番処理</b>を行わなければなりません。
それらの定番処理をDBFluteで自動生成したものがBehaviorとなります。

他のO/R-Mapperで似た位置付けを挙げるならば、
「Hibernateで言うDao」、「Torqueで言うPeer」に相当します。


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
厳密な意味がどうでもいい人は、
<b>「DBFluteではBehaviorを使って検索したり更新したりする」</b>と覚えてもらうだけで構いません。
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 


# ----------------------------------------------------------
#                                      The merit of behavior
#                                      ---------------------

先に挙げた“Paging処理”を例にとって比較します。

Paging処理は一般的に以下のような処理になります。

    1. Paging条件無しの時の全件Record数の検索 → select count(*) from xxx
    2. Paging条件ありでの検索 → select ... from xxx limit 20 offset 40
    3. {1}と{2}の結果から総Page数や次Page存在判定などの計算

こういった処理の再利用を解決します。

  {Behaviorを利用しない}
    呼び出し側が{1}-{2}-{3}の処理を手続き的に行います。
    Daoを使って{1}と{2}を実行し、{3}の処理を呼び出し側が自分で行います。
    その辺の処理の再利用を自分で考える必要があります。

      ex) BOOK一覧のPaging検索
      /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
      final BookDao bookDao = [...DaoのInstanceを取得]
      final BookCB cb = new BookCB();
      [...ConditionBean(条件)の設定]
      cb.fetchFirst(20); // 1PageのSizeは20件
      cb.fetchFirst(3);  // 3Page目を検索したい
      <b>final int allRecordCount = bookDao.selectCount(cb); // {1}の処理を実行</b>
      <b>final java.util.List&lt;Book&gt; bookList = bookDao.selectList(cb); // {2}の処理を実行</b>
      <b>[...結果から計算] // {3}の処理を実行 ※ここが大変(Bugも生みやすい)</b>

      // Paging結果のHandling
      <b>[...Pagingの結果情報がバラバラなので必要に応じて独自のDTOにまとめる] // ※ここも面倒である</b>
      - - - - - - - - - -/

  {Behaviorを利用する}
    {1}-{2}-{3}の処理を自動生成された一行のMethod呼び出しで完了します。
    こういったApplication依存でない<b>「DaoとEntityの定番処理」</b>の再利用が既に解決されています。

      ex) BOOK一覧のPaging検索 -- selectPage()
      /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
      final BookBhv bookBhv = [...BehaviorのInstanceを取得]
      final BookCB cb = new BookCB();
      [...ConditionBean(条件)の設定]
      cb.fetchFirst(20); // 1PageのSizeは20件
      cb.fetchFirst(3);  // 3Page目を検索したい
      <b>final PagingResultBean&lt;Book&gt; bookPage = bookBhv.selectPage(cb); // {1}-{2}-{3}の処理を実行</b>

      // Paging結果のHandling
      <b>[...単一ObjectのbookPageからPaging結果に関する全ての情報が取得できる]</b>
      - - - - - - - - - -/


また、BehaviorもEntityやDaoと同様にGenerationGapになっているため、Application独自の処理を
実装することも可能です。該当のTableが持つ固有のLogic(Dataの振舞い)をBehaviorに実装し、
複数のProcess(画面やBatchなど)で利用するLogicの再利用を解決することが可能です。


# ----------------------------------------------------------
#                                        How to use behavior
#                                        -------------------

Behaviorは、dbflute.diconにてInterfaceを持たないClassとしてComponent登録されます。
Interfaceを持たないため、Setter-Injectionされるか否かはS2ContainerのVersionに依存します。

利用したいBehaviorのComponentNameと同名のSetterを用意すればInjectionされます。

    / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    public class Xxx {
        public void setBookBhv(BookBhv bookBhv) {
            this.bookBhv = bookBhv;
        }
        public void executeXxx() {
            final Book entity = Book();
            entity.setBookId(123);
            entity.setBookName("xxx");
            this.bookBhv.insertOrUpdate(entity);
        }
    }
    - - - - - - - - /


# ----------------------------------------------------------
#                   What kind of methods does behavior have?
#                   ----------------------------------------

<a href="tips-behavior-method_for_use.html">Behaviorの用途別Method概要</a> をご覧下さい。



# ---------------------------------------------------------
#                               The other merit of behavior
#                               ---------------------------

BehaviorはS2Daoの“クセ”を隠蔽します。

冒頭で挙げた“整合性Check”というのがそれに該当します。


【ParameterのCheck】
Parameterに対する整合性Checkを掛けることができます。

  {Behaviorを利用しない}
    S2DaoのDaoは、Interfaceのみが存在していて、Methodが呼び出された後の処理に対して
    Applicationで手を加えることが一切できません。(やるとなったらInterceptorになってしまう)
    なので、ParameterのNullCheckなど呼び出し側が随時やる必要があります。

  {Behaviorを利用する}
    Behaviorで自動生成されたMethodは引数の厳密なCheckとDebug用Messageを格納した例外発生を行います。
    呼び出し側がMethod呼び出し前にCheckしたり、Debugしづらい例外が発生してしまうことはありません。


【戻り値の整合性Check】
1件を期待しているのに複数件HITしてしまった場合の扱いが違います。

  {Behaviorを利用しない}
    S2DaoのDaoの“戻り値がEntity型の1件検索Method(selectEntity())”は、
    S2Daoの仕様として「SQLが複数件数を返してきた場合は最初の1件を返す」となっています。
    実開発においては、「例外にして欲しい」と思うところです。
    (1件を期待しているのに複数件だったら既に条件かDataかどこかにBUGあるため)

  {Behaviorを利用する}
    1件を期待しているのに複数件だったら専用の例外になります。
    もし最初の1件を検索したい場合は、Paging機能で先頭の1件だけを指定して検索すれば実現できます。

      ex) BOOKの1件検索 -- selectEntity()
      /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
      final BookBhv bookBhv = [...BehaviorのInstanceを取得]
      final BookCB cb = new BookCB();
      [...ConditionBean(条件)の設定]
      final Book book = bookBhv.selectEntity(cb); // NullCheckが行われる。
      - - - - - - - - - -/

また、既に絶対1件HITすることが前提の検索Methodが存在します。

  {Behaviorを利用しない}
    また、S2DaoのDaoの“戻り値がEntity型の1件検索Method(selectEntity())”は0件HIT時にnullを返します。
    実開発においては、「既に絶対1件HITすることが前提」で検索することがかなり多いです。
    そのとき、呼び出し側がいちいち戻り値をNullCheckするのは面倒ですし、Checkせずに
    Data不備でnullが帰ってきて、NullPointerExceptionが発生するのも効率が悪いです。

  {Behaviorを利用する}
    0件取得時にDebug用Messageを格納した例外発生を行います。

      ex) BOOKの1件検索 -- selectEntityWithDeletedCheck()
      /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
      final BookBhv bookBhv = [...BehaviorのInstanceを取得]
      final BookCB cb = new BookCB();
      [...ConditionBean(条件)の設定]
      final Book book = bookBhv.selectEntityWithDeletedCheck(cb); // 戻り値のNullCheckが行われる。
      assertNotNull(book); // bookがnullになることは絶対にない
      - - - - - - - - - -/


これらはちょっとした実装補助ではありますが、10人20人と開発者が増えれば増えるほど効果を発揮します。
「このちょっとした実装補助が無いためにDebugに時間を掛けてしまった」なんてことは避けたいと考えます。
(呼び出し側はBehaviorのみ利用し、S2DaoのDaoを直接参照しないことを推奨)

</pre>
</p>

<!-- document end -->
</html>
