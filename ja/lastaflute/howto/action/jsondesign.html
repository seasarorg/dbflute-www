<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja" >
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta name="keywords" content="DBFlute,LastaFlute,Java,Lean Startup,Incremental Development" />
	<link rel="stylesheet" type="text/css" href="../../../../css/lasub.css" />
	<!--[if IE 6.0]>
		<link rel="stylesheet" type="text/css" href="../../../../css/cb/sub.css" />
	<![endif]--> 
	<title>JSON APIのJSONデザイン | LastaFlute</title>
</head>
<body>
<div id="container" class="ct-default">

<div id="mainbar">
<div id="header">
	<div class="navi-upper"><a href="../../../../ja/sitemap.html">SiteMap</a>|<a href="http://d.hatena.ne.jp/jflute/">Author's Blog</a></div>
	<div class="navi-main">
	<ul>
		<li class="hd-introduction"><a href="../../../../ja/introduction/index.html"><img src="../../../../image/parts/navi/link-intro.png" alt="Introduction" width="75" height="32" /></a></li>
		<li class="hd-tutorial"><a href="../../../../ja/tutorial/index.html"><img src="../../../../image/parts/navi/link-tuto.png" alt="Tutorial" width="56" height="24" /></a>
			<ul>
				<li class="hd-architect"><a href="../../../../ja/tutorial/architect.html"><img src="../../../../image/parts/navi/link-arch.png" alt="for Architect" width="80" height="24" /></a></li>
				<li class="hd-developer"><a href="../../../../ja/tutorial/developer.html"><img src="../../../../image/parts/navi/link-dev.png" alt="for Developer" width="87" height="24" /></a></li>
			</ul>
		</li>
		<li class="hd-environment"><a href="../../../../ja/environment/index.html"><img src="../../../../image/parts/navi/link-env.png" alt="Environment" width="84" height="25" /></a>
			<ul>
				<li class="hd-install"><a href="../../../../ja/environment/setup/index.html"><img src="../../../../image/parts/navi/link-setup.png" alt="Setup" width="42" height="24" /></a></li>
				<li class="hd-upgrade"><a href="../../../../ja/environment/upgrade/index.html"><img src="../../../../image/parts/navi/link-upgrade.png" alt="Upgrade" width="61" height="25" /></a></li>
			</ul>
		</li>
		<li class="hd-manual"><a href="../../../../ja/manual/index.html"><img src="../../../../image/parts/navi/link-manual.png" alt="Manual" width="62" height="25" /></a></li>
	</ul>
	</div>
</div>

<div id="content">
	<h1>JSON APIのJSONデザイン</h1>
	<div class="relatedpage"><a href="../../index.html">LastaFlute</a></div>
	<p>
		LastaFluteのドキュメントではありますが、どんなフレームワークを使っていても JSON API
		を構築するときに通じるお話かもしれません。
	</p>
	<p>
		一方で、jfluteもまだまだ研究中のテーマなので、何か要因が見つかれば随時更新していきます。
	</p>
	<ul class="indexlist">
		<li><a href="#overview">概要</a></li>
		<li><a href="#jsonnuance">A. そもそもJSONをどんなニュアンスで戻す？</a>
			<ul>
				<li><a href="#resourceordisplay">元データ方式？表示データ方式？</a></li>
				<li><a href="#basicconcept">様々な判断の基本コンセプトに</a></li>
				<li><a href="#resourcebasis">どちらかと言えば元データ方式推奨？</a></li>
			</ul>
		</li>
		<li><a href="#jsonerrorexp">B. エラー表現 <span class="frm">(Failure統一？共通ヘッダー？)</span></a>
			<ul>
				<li><a href="#failureunified">Failure統一パターン</a></li>
				<li><a href="#commonheader">共通ヘッダーパターン</a></li>
				<li><a href="#failureorheader">Failure統一？共通ヘッダー？ or ...</a></li>
			</ul>
		</li>
		<li><a href="#jsonresponse">C. JSONのデータ型 <span class="frm">型付き？型なし？</span></a>
			<ul>
				<li><a href="#typedjson">型付きJSONパターン</a></li>
				<li><a href="#notypedjson">型なしJSONパターン</a></li>
				<li><a href="#typedjsonbasis">かなり強めに型付きJSONが推奨？</a></li>
			</ul>
		</li>
		<li><a href="#dateformat">D. 日付フォーマット <span class="frm">クライアント？サーバー？</span></a>
			<ul>
				<li><a href="#formatbyserverorclient">クライアントでフォーマット？サーバーでフォーマット？</a></li>
				<li><a href="#dependsonnuance">どんなニュアンスで戻すか次第</a></li>
				<li><a href="#dependsonnuance">LastaFluteだとどんな実装に？</a></li>
				<li><a href="#i18ndate">国際化対応するときはまた色々と</a></li>
				<li><a href="#clientformatbasic">日付フォーマットはクライアントで解決がオススメ？</a></li>
			</ul>
		</li>
		<li><a href="#keystyle">E. メッセージ管理: <span class="frm">クライアント？サーバー？</span></a></li>
		<li><a href="#keystyle">F. キーのケース: <span class="frm">キャメル？スネーク？</span></a></li>
		<li><a href="#messagemanage">G. まだまだありそうだけど？</a></li>
		<li><a href="#failureorheader">最初のAPIのデザインが会社標準デザイン</a></li>
	</ul>

	<h2 id="overview">概要</h2>
	<p>
		JSON APIを作ろうとしている人は、実装する前に必ずこれを決めましょう。
	</p>
	<ul>
		<li>A. そもそもJSONをどんなニュアンスで戻す？</li>
		<li>B. エラー表現: Failure統一パターン？共通ヘッダーパターン？</li>
		<li>C. JSONのデータ型: 型ありJSON？型なしJSON？</li>
		<li>D. 日付フォーマット: クライアントフォーマット？サーバーフォーマット？</li>
		<li>E. メッセージ管理: クライアントメッセージ構築？サーバーメッセージ構築？</li>
		<li>F. キーのケース: キャメルケース？スネークケース？</li>
		<li>G. まだまだありそうだけど？</li>
	</ul>
	<p>
		<span class="frm">※というか、JSON APIじゃなくても(サーバーサイドHTMLでも)、Ajax で JsonResponse
		を受け取るメソッドをたくさん作るのであれば同じことです。</span>
	</p>

	<h2 id="jsonnuance">A. そもそもJSONをどんなニュアンスで戻す？</h2>
	<h3 id="resourceordisplay">元データ方式？表示データ方式？</h3>
	<p>
		あくまでJSONでデータを戻すわけですが、厳密なニュアンスを決めておいたほうが良いです。
	</p>
	<dl class="keymainlist">
		<dt>画面に表示するための元データ</dt><dd>画面でどう表示するかはあまり意識しない素のデータを戻す</dd>
		<dt>画面にそのまま表示するデータ</dt><dd>画面を意識してフォーマットされたデータを戻す</dd>
	</dl>
	<p>
		クライアントが画面じゃないなら、そのクライアントに依存する処理を想像すると良いでしょう。
	</p>
	<p>
		わかりやすいのは、"D. 日付フォーマット" での話と関連する、日付のデータの例です。
		例えば、クライアントで yyyy/MM/dd で表示するとします。
		JSON自体での転送データはISO標準の yyyy-MM-dd'T'HH:mm:ss.SSS にして、クライアントで yyyy/MM/dd
		にするのであれば <em class="mark">元データ方式</em> です。そうではなく、JSONのデータも yyyy/MM/dd 形式で渡そうと思うなら、<em class="mark">表示データ方式</em> です。
	</p>
	<dl class="shortkeymainlist">
		<dt>元データ方式</dt><dd>転送は yyyy-MM-dd'T'HH:mm:ss.SSS で、クライアントで yyyy/MM/dd</dd>
		<dt>表示データ方式</dt><dd>転送自体が yyyy/MM/dd <span class="frm">(サーバーで変換しても戻す)</span></dd>
	</dl>
	<p>
		元データ方式のメリットは、クライアントのロジックにサーバーが依存しないので、日付フォーマットが変わってもサーバーの再リリースは不要です。
		また、そのAPIを再利用しやすくなります。iPhone や Android, JavaScript
		で表示ロジックが若干違ったとしても同じAPIを呼びやすくなります。
	</p>
	<p>
		表示データ方式のメリットは、画面の表示ロジックなどがサーバーで一極集中管理できることです。
	</p>
	<h3 id="basicconcept">様々な判断の基本コンセプトに</h3>
	<p>
		細かい話ですが、これがJSONデザインにおける様々な判断の基本コンセプトになります。
		このコンセプトが決まれば、この後の判断は自動的に決まったりもします。
		なのでまず、その JSON API で何を戻すのか？どういうニュアンスのデータを戻すのか？
		しっかり考えましょう。
	</p>
	<p>
		それがあやふやなまま作り始めると、APIクラスごとに違うポリシーで実装されて、チグハグな状態になります。
		とあるAPIでは表示の変更はクライアントの修正なのに、とあるAPIではサーバーの再起動を必要としたりと。
	</p>
	<div class="inucolumn">
		<h3 id="resourcebasis">どちらかと言えば元データ方式推奨？</h3>
		<p>
			どちらでも実現はできますが、インクリメンタル開発の現場での組織的なことを考えると、
			クライアントの些細なロジックにサーバーのロジックが依存するのはリリース運用が非常にやりづらいケースが多いと想定されるので、
			jfluteはなんのしがらみもなければ "元データ方式" を採用します。
		</p>
		<p>
			また、LastaFluteではJSONのクラスにネイティヴ型 (Integer や LocalDate など)
			が定義できるので、元データ方式でそのままタイプセーフな型を使うことができた方が、UnitTestなどもやりやすく安全です。
		</p>
		<p>
			もちろん、APIは潜在的にクライアントに依存しがちです。
			なので、ある程度は仕方ないですが、あまりに細かいレベルで極端に依存しているつらいので、緩和するというニュアンスですね。
		</p>
	</div>

	<h2 id="jsonerrorexp">B. エラー表現 <span class="frm">(Failure統一？共通ヘッダー？)</span></h2>
	<p>
		JSON API の処理の中で、エラーが発生したとき...システム例外、クライアント例外、業務例外、バリデーションエラー含めて、正常系のレスポンスを戻せなかったときどうするか？
	</p>
	<p>
		様々なパターンがありますが、ここではざっくりと二つのパターンを紹介します。必ず実装する前に考えましょう。
		<em class="mark">Failure統一パターン</em> と <em class="mark">共通ヘッダーパターン</em> です。
	</p>
	<h3 id="failureunified">Failure統一パターン</h3>
	<h4>正常系のJSON</h4>
	<p>
		正常なときは、普通にその業務の JSON を戻します。
	</p>
<pre><span class="codetitle">e.g. Failure統一パターンでの正常系のときのJSON戻り、ここでは商品一覧 @Json</span><code>
{
    "productList" : [
        <span class="abbreviation">...</span>
    ]
}
</code></pre>
	<h4>エラー系のJSON</h4>
	<p>
		エラーのときだけ、共通的なフォーマットで JSON を戻します。
	</p>
<pre><span class="codetitle">e.g. Failure統一パターンでのエラーのときのJSON戻り、ここではバリデーションエラー @Json</span><code>
{
    "failureType" : VALIDATION_ERROR
    , "messageMap" : {
        <span class="abbreviation">...</span>
    }
}
</code></pre>
	<p>
		そのとき、どんなエラーだったのかを表す項目を戻します。エラーの場合はメッセージが付きものなのでエラーメッセージも戻します。
		<span class="frm">(メッセージは、メッセージそのものか？メッセージを示すキーか？デザインに寄ります: 詳しくは "D. メッセージ管理" にて)</span>
	</p>
	<h4>HTTPステータスはどのように戻すのか？</h4>
	<p>
		HTTPステータスは、正常系は200, エラー系は400系 もしく、500系で戻します。
	</p>
	<dl class="lolongvaluemainlist">
		<dt>正常系</dt><dd>200</dd>
		<dt>エラー系</dt><dd>バリデーションエラーや業務例外なら400系、システム例外は500系</dd>
	</dl>
	<h4>クライアントはどのように判断するのか？</h4>
	<p>
		まずは、HTTPステータスで判断します。200ならそのまま業務のJSONとしてパース、400/500系なら統一的なJSONとしてパースして処理。
	</p>
	<p>
		クライアントサイドの実装イメージです。クライアントの共通部品でこのような実装をすると良いでしょう。
		Javaっぽいコードですが単にExampleロジックを示したいだけなので、参考までにと。実際の要件に照らし合わせて微調整しましょう。
		また、多くのクライアントの仕組みで正常系とエラー系は自動的に振り分けられると想定されるので、実際にはもっとシンプルになるかと思います。
	</p>
<pre><span class="codetitle">e.g. Failure統一パターンでのクライアントサイドのJSONパースの共通部品での実装イメージ @Java?</span><code>
<span class="keyword">if</span> (HTTP Status: <span class="literal">200</span>) { <span class="comment">// success</span>
    XxxJsonResult <span class="localvar">result</span> = parseJsonAsSuccess(<span class="localvar">response</span>);
    <span class="comment">// do process per action</span>
    <span class="abbreviation">...</span>
} <span class="keyword">else if</span> (HTTP Status: <span class="literal">400</span>) { <span class="comment">// e.g. validation error, application exception, client exception</span>
    FailureResult <span class="localvar">result</span> = parseJsonAsFailure(<span class="localvar">response</span>);
    <span class="comment">// show result.messageMap or do process per result.failureType</span>
    <span class="abbreviation">...</span>
} <span class="keyword">else if</span> (HTTP Status: <span class="literal">404</span>) { <span class="comment">// e.g. real not found, invalid parameter</span>
    showNotFoundError();
} <span class="keyword">else</span> { <span class="comment">// basically 500, server exception</span>
    showSystemError();
}
</code></pre>
	<h4>Failure統一パターンのメリット</h4>
	<p>
		共通ヘッダーパターンと比べてのメリットを挙げてみます。
	</p>
	<dl class="textlist">
		<dt>正常系のJSONに余計なものがない</dt>
		<dd>
			正常系はいたってシンプル、その業務のJSONだけになる。
		</dd>
		<dd>
			共通ヘッダーパターンだと、正常系でもほとんど使わないヘッダーが付くので、
			その文字列の分、出力処理とパース処理に時間がかかるし、JSON自体のサイズも大きくなる。
			<span class="frm">(一つ一つは大したことなくても、アクセス数の多いサービスだったり、マイクロサービスアーキテクチャなどに寄せていったりすると、どんどんボトルネックになってくる)</span>
		</dd>
		<dt>クライアントサイドがシンプル</dt>
		<dd>
			HTTPの仕組みをある程度使うことで、<em class="keyword">既存の仕組みの乗っかって</em> 処理ができる。
			例えば、アプリケーションサーバーやフレームワーク内で発生する 404 や 500
			エラーも統一的にハンドリングできる。
		</dd>
		<dd>
			共通ヘッダーパターンだと、200の中でのエラー分岐に加えて、HTTPステータスの分岐も必要になる。
		</dd>
		<dt>インフラで正常系の判断がしやすい</dt>
		<dd>
			HTTPステータスを使っているので、例えばインフラ側でAPIの結果をキャッシュするなど仕組みを入れる場合に、
			正常系だけをキャッシュ対象にしたいときなど、HTTPの仕組みだけで判断しやすくなります。
		</dd>
	</dl>
	<p>
		<span class="frm">※デメリットは "共通ヘッダーパターンのメリットの逆" を考えると良いでしょう。</span>
	</p>
	<h4>限定的ヘッダーパターンはまた別</h4>
	<p>
		ページングの結果を戻すAPIときに、ページサイズやページ番号を戻すような共通的なヘッダーを付与するのは、
		Failure統一パターンの中でも利用することはあります。
		200の結果の中で限定的なスコープで業務的な共通的なヘッダーは、それはそれでまたレイヤの違う話なので、効率的であれば全然使っても良いでしょう。
	</p>
	<h4>LastaFluteではどう実装する？</h4>
	<p>
		LastaFlute の Example (harbor, maihama)
		では、デフォルトでFailure統一パターンになっていますので、そちらを参考に。
		Example からスタートアップした場合は、そのまま [App]ApiFailureHook
		を育てていけばOKです。
	</p>
	<div class="detailpage"><a href="https://github.com/lastaflute/lastaflute-example-harbor/blob/master/src/main/java/org/docksidestage/mylasta/direction/sponsor/HarborApiFailureHook.java#L37">HarborApiFailureHook.java | Github</a></div>
	<h3 id="commonheader">共通ヘッダーパターン</h3>
	<h4>正常系、エラー系に関係なく共通ヘッダー</h4>
	<p>
		正常系、エラー系に関係なく、一律共通ヘッダー的な項目を追加して、エラーかどうかの判定はすべてアプリ独自の項目で表現する。
		HTTPステータスは、どんなときでも 200 を戻します<span class="frm">(NullPointerExceptionでも200)</span>。
	</p>
<pre><span class="codetitle">e.g. 共通ヘッダーパターンの正常系のときのJSON戻り、ここでは商品一覧 @Json</span><code>
{
    "header" : {
        "failureType" : SUCCESS
        , "messageMap" : {} <span class="comment">// 正常系はメッセージがないのでだいたい空っぽ</span>
    }
    , "body" : {
        "productList" : [
            <span class="abbreviation">...</span>
        ]
        <span class="abbreviation">...</span>
    }
}
</code></pre>
<pre><span class="codetitle">e.g. 共通ヘッダーパターンのエラー系のときのJSON戻り、ここではバリデーションエラー @Json</span><code>
{
    "header" : {
        "failureType" : SUCCESS
        , "messageMap" : {
            <span class="abbreviation">...</span>
        }
    }
    , "body" : {} <span class="comment">// エラー系はBodyデータがないので空っぽ</span>
}
</code></pre>
	<h4>クライアントはどのように判断するのか？</h4>
	<p>
		共通ヘッダーパターンでも、HTTPステータスは無視できません。
		アプリケーションサーバーやフレームワークのエラーがHTTPステータスで戻ってくる可能性があるからです。
		<span class="frm">(どれだけ奥深いレイヤまで頑張っても、HTTPである限りはあり得ることなので)</span>
	</p>
	<p>
		クライアントサイドの実装イメージです。クライアントの共通部品でこのような実装をすると良いでしょう。
		Javaっぽいコードですが単にExampleロジックを示したいだけなので、参考までにと。実際の要件に照らし合わせて微調整しましょう。
	</p>
<pre><span class="codetitle">e.g. 共通ヘッダーパターンでのクライアントサイドのJSONパースの共通部品での実装イメージ @Java?</span><code>
<span class="keyword">if</span> (HTTP Status: <span class="literal">200</span>) { <span class="comment">// success</span>
    CommonJsonResult <span class="localvar">result</span> = parseJson(<span class="localvar">response</span>);
    <span class="keyword">if</span> (Business Status: <span class="literal">200</span>) { <span class="comment">// success</span>
        <span class="comment">// do process per action</span>
        <span class="abbreviation">...</span>
    } <span class="keyword">else if</span> (Business Status : <span class="literal">404</span>) { <span class="comment">// e.g. business not found, invalid parameter</span>
        showNotFoundError();
    } <span class="keyword">else</span> { <span class="comment">// basically 500, server exception</span>
        showSystemError();
    }
} <span class="keyword">else if</span> (HTTP Status: <span class="literal">400</span>) { <span class="comment">// e.g. validation error, application exception, client exception</span>
    FailureResult <span class="localvar">result</span> = parseJsonAsFailure(<span class="localvar">response</span>);
    <span class="comment">// show result.messageMap or do process per result.failureType</span>
    <span class="abbreviation">...</span>
} <span class="keyword">else if</span> (HTTP Status: <span class="literal">404</span>) { <span class="comment">// e.g. real not found, invalid parameter</span>
    showNotFoundError();
} <span class="keyword">else</span> { <span class="comment">// basically 500, server exception</span>
    showSystemError();
}
</code></pre>
	<h4>共通ヘッダーパターンのアンチパターン</h4>
	<p>
		共通ヘッダーがあると、ついつい色々な項目を付け足したくなります。
		例えば、"ページングのページサイズ" や "更新件数" など、とある業務に特化しているけれどもわりと多くのAPIで使うものなどを入れていくと、
		どんどん共通ヘッダーが <em class="mark">最小公倍数化</em> していきます。
		こうなると、共通ヘッダーを意識せずに実装することができなくなるため、クライアントサイドもサーバーサイドも、いたるところで共通ヘッダーを無視できないジレンマを抱えるでしょう。
		<span class="frm">(実際に、共通ヘッダーパターンの現場で発生しているのを見かけます)</span>
	</p>
	<p>
		共通ヘッダーをやるなら、<em class="keyword">APIのやり取りをマネジメントするための項目だけに使う</em>
		つまり、共通部品だけがそれらの項目を利用するという状態をキープするほうが良いでしょう。
	</p>
	<p>
		APIのバージョンを含める、というケースもよく見かけます。これが悪いとは言えませんが、HTTPヘッダーを使うという選択肢もあります。
		その辺も踏まえてしっかりとデザインすると良いでしょう。
	</p>
	<h4>共通ヘッダーパターンのメリット</h4>
	<p>
		ごめんなさい、あまり思いつきませんでした...
	</p>
	<dl class="textlist">
		<dt>正常系のメッセージの共通化</dt>
		<dd>
			正常系でもメッセージを共通化できる。
			<span class="frm">(ただ、正常系でメッセージを戻す場面がそもそもあまり多くはないので、共通化のメリットはあまりないかも。常にメッセージを戻すようなシステムであればというところで)</span>
		</dd>
	</dl>
	<p>
		<span class="frm">※デメリットは "Failure統一パターンのメリットの逆" を考えると良いでしょう。</span>
	</p>
	<h4>LastaFluteではどう実装する？</h4>
	<p>
		LastaFluteは、共通ヘッダーパターンに対して積極的なサポートをしていません。
		もちろん、もともとアプリで全部管理するという話なので、LastaFluteの機能を気にせずやろうと思えばできますが、
		Exampleとしては用意がありませんので、わりと手続きが必要になるかと思います。
		<span class="frm">(共通ヘッダー用のResultクラスを作ったり、ApiFailureHookですべて200でも戻すようにしたり)</span>
	</p>
	<p>
		この辺は、今後のフィードバックで共通ヘッダーパターンのメリットがもっと明確になってきたときにサポートを検討しようかなと思っています。
	</p>
	<div class="inucolumn">
		<h3 id="failureorheader">Failure統一？共通ヘッダー？ or ...</h3>
		<p>
			jfluteの業務経験としては両方あるので、どちらでも実現はできますが、特になんのしがらみもない環境であれば "Failure統一パターン"
			を採用します。
		</p>
		<p>
			もし、共通ヘッダーを採用するなら、それこそ jflute にたくさん聞いてください。
			何も考えずにやるとアンチパターンに陥りやすいし、共通ヘッダー部分のResultクラスをどう表現するか？Actionクラスでどう表現するか？
			インフラ側でエラーの判断をしてもらうためにはどうするか？などなど、独自でやってへんてこりんになっても悲しいですから。
		</p>
		<p>
			世の中の記事を読んでいると、もっと色々なケースありますよね。そもそも REST にするとか、HTTPステータスをもっと細かく活用していこうとか、
			HTTPヘッダーをもっと活用していこうとか。そういう意味では、ここで紹介したパターンに色々と微調整をしていくのもアリです。
		</p>
		<p>
			大事なのは、しっかり思想を持ってデザインして決めること。"なあなあ" で決めないこと。
		</p>
	</div>

	<h2 id="jsonresponse">C. JSONのデータ型 <span class="frm">型付き？型なし？</span></h2>
	<p>
		JSONのデータ型をどうするか？
	</p>
	<h3 id="typedjson">型付きJSONパターン</h3>
	<h4>普通のJSON</h4>
	<p>
		いわゆる普通のJSON。TSVなどと違ってJSONには型の概念があり、それを有効活用します。
	</p>
<pre><span class="codetitle">e.g. 型付きJSONパターンのJSON @Json</span><code>
{
    "productId" : <span class="literal">7</span>
    , "productName" : <span class="literal">"Sea"</span>
    , "soldOutFlg" : <span class="keyword">false</span>
    , "saleDatetime" : <span class="keyword">null</span>
    <span class="abbreviation">...</span>
}
</code></pre>
	<h4>型付きJSONパターンのメリット</h4>
	<p>
		型なしに比べてのメリットを挙げてみます。
	</p>
	<dl class="textlist">
		<dt>ネイティヴ型が使える</dt>
		<dd>
			クライアント側で、Integer や Boolean
			などネイティヴ型がそのまま受け取りのクラスで利用しやすいので、それぞれの業務コードで変換処理などが不要。
		</dd>
		<dd>
			型なしでも、JSONパーサーの工夫次第でネイティヴ型に変換はできるが、JSON APIのクライアントが様々な場合、その工夫ロジックをいたるところで入れないといけない。
			<span class="frm">(すぐ次の、"どのJSONパーサーでも普通にパース" に絡む)</span>
		</dd>
		<dt>どのJSONパーサーでも普通にパース</dt>
		<dd>
			一般的なので、特にJSONパーサーに何か微調整をあまり入れなくても利用しやすい。
		</dd>
		<dd>
			マイクロサービスアーキテクチャに寄っていくと、様々なクライアントが発生するので、それぞれのクライアントのJSONパーサーに微調整を入れるとなると大変。
		</dd>
		<dt>クライアントもわかりやすい</dt>
		<dd>
			サーバーサイドのドキュメントは見るにせよ、JSONを見て型がわかれば "ここは数値なんだ (数字しか来ないんだ)"
			とクライアントの人が判断をしやすい。すべて文字列になってると数字しか来ないことを確定できなくて安心できない。
		</dd>
		<dt>JSON上でもわかりやすい</dt>
		<dd>
			なんだかんだ、デバッグやトラブルシューティングでJSONを見ることがあり、そのとき型があるとわかりやすい。
		</dd>
	</dl>
	<p>
		<span class="frm">※デメリットは "型なしJSONパターンのメリットの逆" を考えると良いでしょう。</span>
	</p>
	<h3 id="notypedjson">型なしJSONパターン</h3>
	<h4>型をなくしたAll文字列型のJSON</h4>
	<p>
		TSVのように、すべて文字列で取り扱うJSON。nullも "" として表現する。
	</p>
<pre><span class="codetitle">e.g. 型ありのJSONパターンのJSON @Json</span><code>
{
    "productId" : <span class="literal">"7"</span>
    , "productName" : <span class="literal">"Sea"</span>
    , "soldOutFlg" : <span class="literal">"false"</span>
    , "saleDatetime" : <span class="literal">""</span> <span class="comment">// 値がないことを空文字で表現</span>
    <span class="abbreviation">...</span>
}
</code></pre>
	<h4>型なしJSONパターンのメリット</h4>
	<p>
		ごめんなさい、あまり思いつきませんでした...
	</p>
	<dl class="textlist">
		<dt>表示データ方式ならフィットする</dt>
		<dd>
			"A. そもそもJSONで何を戻す？" であったように、そのまま表示できるデータをサーバーサイドが戻す方式なら、
			クライアントはそのままもらったデータを何も考えず表示するだけなので、文字列型で問題ない。
			<span class="frm">(ただ、必ずしも相手が画面とは限らないので、API to API の場合は結局あまり意味がないかも)</span>
		</dd>
	</dl>
	<p>
		<span class="frm">※デメリットは "型付きJSONパターンのメリットの逆" を考えると良いでしょう。</span>
	</p>
	<div class="inucolumn">
		<h3 id="typedjsonbasis">かなり強めに型付きJSONが推奨？</h3>
		<p>
			"どちらかと言えば" ではなく、かなり強めに "型付きJSON" をお奨めしています。
		</p>
		<p>
			これまた jflute は両方を経験したことがあります。
			"型なしJSON" だと、もろに "型付きJSONのメリットの反対" を食らいます。
		</p>
		<p>
			最初はAPIサービス自体が少なく、最初に開発した画面実装にかなり依存した形で作り、だんだんとマイクロサービスアーキテクチャ寄りになっていったときに、
			一般的ではないJSONの取り扱いがネックになり、色々なJSONパーサーで工夫を入れないといけなくなってしまいがちです。
			それが、外部のAPIにまで波及し、外部クライアント(他社)のエンジニアにまでが、その工夫を強いられていることになったり。
		</p>
		<p>
			特に、nullを空文字として表現するのが大変だったという印象です。数値型で値がないときに ""
			になっていて、パーサーで落ちるとか。jfluteが管理しやすい範囲のプロジェクトならいいですが、どんどん色々なクライアントが出てきて、
			そうでないプロジェクトでトラブルになったり。 
		</p>
		<p>
			一応、LastaFluteで、型なしでもネイティヴ型に変換するための工夫は入られれます。
			Exampleでもこのやり方はしていないので、実装方法はMLなどで聞いてください。
			ですが、まず "なぜ型なしにするのでしょうか？" と聞かせて頂くかと思います。
			<span class="frm">(いまわかっていないメリットがあるなら、また話は別ですし)</span>
		</p>
	</div>

	<h2 id="dateformat">D. 日付フォーマット <span class="frm">クライアント？サーバー？</span></h2>
	<h3 id="formatbyserverorclient">クライアントでフォーマット？サーバーでフォーマット？</h3>
	<p>
		サーバーはISO標準で戻して、クライアントで日付フォーマットするか？
	</p>
<pre><span class="codetitle">e.g. 日付をISO標準で戻す @Json</span><code>
{
    "seaBeginDatetime" : <span class="point">"2001-09-04T12:34:56"</span> <span class="comment">// ISO標準</span>
}
</code></pre>
	<p>
		サーバーですでに日付フォーマットしてから戻して、クライアントでは単に表示するだけか？
	</p>
<pre><span class="codetitle">e.g. 日付を画面で表示する形で戻す @Json</span><code>
{
    "seaBeginDatetime" : <span class="point">"2001/09/04 12:34:56"</span> <span class="comment">// 画面で表示する形</span>
}
</code></pre>
	<p>
		要は...
	</p>
	<dl class="longkeymainlist">
		<dt>クライアント日付フォーマット方式</dt><dd>サーバーはISO標準で戻し、クライアントでフォーマット</dd>
		<dt>サーバー日付フォーマット方式</dt><dd>サーバーでフォーマットして戻し、クライアントは表示のみ</dd>
	</dl>
	<h3 id="dependsonnuance">どんなニュアンスで戻すか次第</h3>
	<p>
		これは、まさしく "A. そもそもJSONをどんなニュアンスで戻す？" 次第です。
	</p>
	<div class="relatedpage"><a href="#jsonnuance">this - A. そもそもJSONをどんなニュアンスで戻す？</a></div>
	<dl class="keymainlist">
		<dt>元データ方式</dt><dd>クライアント日付フォーマット方式</dd>
		<dt>表示データ方式</dt><dd>サーバー日付フォーマット方式</dd>
	</dl>
	<p>
		これをはっきりしておかないと、よくあるアンチパターンとしては...
		"サーバーで日付フォーマットしてるのに、クライアントでそれを日付パースして日付型として扱って、改めてフォーマットしてる"
		なんていう、へんてこりんな状況もあり得ます。クライアント側で日付型として扱って処理をしたいのであれば、パースしやすい転送用の日付を戻すほうが良いでしょう。
	</p>
	<p>
		一方で、サーバーで日付フォーマットすると、フォーマットの一元管理がしやすいというメリットはあります。
		クライアント日付フォーマットでも、事前に標準フォーマットを渡しておくなどの処理を入れれば一元管理できますが、その手間が少しかかります。
	</p>
	<h3 id="dependsonnuance">LastaFluteだとどんな実装に？</h3>
	<p>
		LastaFluteでは、LocalDate, LocalDateTimeで定義すれば、デフォルトでISO標準の日付フォーマットで出力されます。
		<span class="frm">(そのデフォルトのフォーマットを変更することもできます)</span>
	</p>
	<p>
		一方で、LocalDate, LocalDateTime のままで、サーバーサイドでフォーマットすることもできます。
		@JsonDatePatternアノテーションでフォーマットを指定すれば、そのようになります。
	</p>
	<div class="relatedpage"><a href="./lajsonapi.html#nativedateformat">素早さのJSON API - LocalDate型の日付フォーマット</a></div>
	<h3 id="i18ndate">国際化対応するときはまた色々と</h3>
	<p>
		国際化対応するときは、また色々と考える必要があるので、また違った話になるでしょう。
	</p>
	<div class="inucolumn">
		<h3 id="clientformatbasic">日付フォーマットはクライアントで解決がオススメ？</h3>
		<p>
			"A. そもそもJSONをどんなニュアンスで戻す？"
			でのロジックの通り、クライアントの細かな表示の都合にサーバーが縛られると再利用やリリース運用的にやりづらいので、
			なんのしがらみもなければ、jfluteやはりクライアント日付フォーマット方式を採用します。
			<span class="frm">(フォーマット変更のためだけにサーバーを再起動するのはつらいかなと)</span>
		</p>
		<p>
			一方で、クライアントが何種類もある場合に、そのクライアント間での統一がしづらいのがジレンマです。
			iPhone, Android, JavaScript のそれぞれのプログラム上で日付フォーマットを持ってしまうのは少し気になります。
			そこまで徹底するなら、サーバーはプロジェクト標準日付フォーマットが含まれたコンフィグのようなものを予めクライアントに渡しておけば良いでしょう。
		</p>
		<p>
			さて、いずれにせよ、最初に決めてないとですね。何よりもバラバラになるのが一番つらい。
		</p>
	</div>

	<h2 id="keystyle">E. メッセージ管理: <span class="frm">クライアント？サーバー？</span></h2>
	<p>
		TODO jflute now writing: これはどっちもありえる
	</p>

	<h2 id="keystyle">F. キーのケース: <span class="frm">キャメル？スネーク？</span></h2>
	<p>
		TODO jflute now writing: これはどっちもありえる
	</p>

	<h2 id="messagemanage">G. まだまだありそうだけど？</h2>
	<p>
		とりあえず、ここまで。また、気づいた時点で追記していきます。
	</p>

	<div class="inucolumn">
		<h2 id="failureorheader">最初のAPIのデザインが会社標準デザイン</h2>
		<p>
			よくあることです。最初に開発するAPIで決めたデザインが、気づいたら会社標準のデザインになっていた、なんてことよくあります。
			これは、アーキテクチャマネジメントをしっかりやらない限り、自然とそうなりがちです。
			その流れで、自然と外部(他社)に公開するAPIもそれになっていたってことも。
		</p>
		<p>
			もう一度利用され始めた API のデザインは、変えられません。公開APIでなくても、クライアントサイドを修正するコストを払えないでしょう。
			もう、向こう5年10年変わらないかもしれません。
			<span class="frm">(多くの現場で、クライアントサイドとサーバーサイドで組織が違ったり、リリースタイミングが違ったりするので、なおさら足並み揃えて変更するというのは無理でしょう)</span>
		</p>
		<p>
			そしてよくあるが、最初に開発したAPIの業務に引きづられたデザイン、それがそのまま全体の標準に。
			でも、標準化するというのも呼び出す側からすると嬉しいことで非常に大切なことなので、一概に悪いわけではないです。
			ただ、それがチグハグだと良くない...。
		</p>
		<p>
			いま決めるものが、5年10年の会社の標準のJSONデザインになる(かもしれない)。
			その覚悟を持って、しっかり思想を持ってデザインして決めること。
		</p>
	</div>

</div>
</div>

<div id="sidebar">
	<div class="logo"><a href="../../../../"><img src="../../../../image/parts/logo.png" alt="dbflute-logo" width="240" height="110" /></a></div>
<ul>
		<li><a href="../../../../ja/lastaflute/index.html">LastaFluteトップページ</a>
			<ul>
				<li><a href="../../../../ja/lastaflute/index.html#about">LastaFluteとは？</a></li>
				<li><a href="../../../../ja/lastaflute/index.html#lacode">LastaFluteのコード</a></li>
				<li class="upper-space"><a href="../../../../ja/lastaflute/index.html#quicktrial">動かしてみよう</a></li>
				<li><a href="../../../../ja/lastaflute/index.html#newproject">新プロジェクト</a></li>
				<li><a href="https://github.com/lastaflute/lastaflute">LastaFlute | Github</a></li>
			</ul>
		</li>
		<li><a href="../../../../ja/lastaflute/tutorial/laimpl.html">LastaFlute実装チュートリアル</a>
			<ul>
				<li><a href="../../../../ja/lastaflute/tutorial/laimpl.html#style">実装スタイル</a></li>
				<li><a href="../../../../ja/lastaflute/tutorial/laimpl.html#prepare">まず準備</a></li>
				<li class="upper-space"><a href="../../../../ja/lastaflute/tutorial/laimpl.html#acquaintanceship">ディベロッパーの心得</a></li>
				<li><a href="../../../../ja/lastaflute/tutorial/laimpl.html#tenclause">ディベロッパーの十か条</a></li>
				<li><a href="../../../../ja/lastaflute/tutorial/faqimpl.html">LastaFluteの実装FAQ</a></li>
			</ul>
		</li>
		<li><a href="../../../../ja/lastaflute/howto/action/index.html">LastaFlute の Action</a>
			<ul>
				<li><a href="../../../../ja/lastaflute/howto/action/makeashtml.html">Actionの作り方 (HTML)</a></li>
				<li><a href="../../../../ja/lastaflute/howto/action/lavalidation.html">Validation</a></li>
			</ul>
		</li>
		<li><a href="../../../../ja/lastaflute/lastadi/index.html">Lasta Diトップページ</a>
			<ul>
				<li><a href="../../../../ja/lastaflute/lastadi/index.html#twocomp">Two Components</a></li>
				<li><a href="../../../../ja/lastaflute/lastadi/dixmlexp.html">Di xml の表現</a></li>
				<li><a href="https://github.com/lastaflute/lasta-di">Lasta Di | Github</a></li>
			</ul>
		</li>
		<li><a href="../../../../ja/tutorial/onjava8.html">DBFlute on Java8</a>
			<ul>
				<li><a href="../../../../ja/tutorial/onjava8.html#select">とにかく検索は？</a></li>
				<li><a href="../../../../ja/tutorial/onjava8.html#completion">さあ、補完してみよう！</a></li>
			</ul>
		</li>
	</ul>

</div>

<div id="footer">
	<div><a href="../../../../ja/sitemap.html">SiteMap</a> <a href="http://d.hatena.ne.jp/jflute">Author's Blog</a><a href="https://www.seasar.org/issues/browse/DBFLUTE">BTS</a></div>
	<ul class="footer-navi">
		<li class="hd-introduction"><a href="../../../../ja/introduction/index.html">Introduction</a></li>
		<li class="hd-tutorial"><a href="../../../../ja/tutorial/index.html">Tutorial</a>
			<ul>
				<li class="hd-architect"><a href="../../../../ja/tutorial/architect.html">for Architect</a></li>
				<li class="hd-developer"><a href="../../../../ja/tutorial/developer.html">for Developer</a></li>
			</ul>
		</li>
		<li class="hd-environment"><a href="../../../../ja/environment/index.html">Environment</a>
			<ul>
				<li class="hd-install"><a href="../../../../ja/environment/setup/index.html">Setup</a></li>
				<li class="hd-upgrade"><a href="../../../../ja/environment/upgrade/index.html">Upgrade</a></li>
			</ul>
		</li>
		<li class="hd-manual"><a href="../../../../ja/manual/index.html">Manual</a></li>
	</ul>

</div>

</div>
</body>
</html>
