<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja" >
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta name="keywords" content="DBFlute,LastaFlute" />
	<link rel="stylesheet" type="text/css" href="../../../../css/lasub.css" />
	<!--[if IE 6.0]>
		<link rel="stylesheet" type="text/css" href="../../../../css/cb/sub.css" />
	<![endif]--> 
	<title>Actionの実装デザイン | DBFlute</title>
</head>
<body>
<div id="container" class="ct-default">

<div id="mainbar">
<div id="header">
	<div class="navi-upper"><a href="../../../../ja/sitemap.html">SiteMap</a>|<a href="http://d.hatena.ne.jp/jflute/">Author's Blog</a></div>
	<div class="navi-main">
	<ul>
		<li class="hd-introduction"><a href="../../../../ja/introduction/index.html"><img src="../../../../image/parts/navi/link-intro.png" alt="Introduction" width="75" height="32" /></a></li>
		<li class="hd-tutorial"><a href="../../../../ja/tutorial/index.html"><img src="../../../../image/parts/navi/link-tuto.png" alt="Tutorial" width="56" height="24" /></a>
			<ul>
				<li class="hd-architect"><a href="../../../../ja/tutorial/architect.html"><img src="../../../../image/parts/navi/link-arch.png" alt="for Architect" width="80" height="24" /></a></li>
				<li class="hd-developer"><a href="../../../../ja/tutorial/developer.html"><img src="../../../../image/parts/navi/link-dev.png" alt="for Developer" width="87" height="24" /></a></li>
			</ul>
		</li>
		<li class="hd-environment"><a href="../../../../ja/environment/index.html"><img src="../../../../image/parts/navi/link-env.png" alt="Environment" width="84" height="25" /></a>
			<ul>
				<li class="hd-install"><a href="../../../../ja/environment/setup/index.html"><img src="../../../../image/parts/navi/link-setup.png" alt="Setup" width="42" height="24" /></a></li>
				<li class="hd-upgrade"><a href="../../../../ja/environment/upgrade/index.html"><img src="../../../../image/parts/navi/link-upgrade.png" alt="Upgrade" width="61" height="25" /></a></li>
			</ul>
		</li>
		<li class="hd-manual"><a href="../../../../ja/manual/index.html"><img src="../../../../image/parts/navi/link-manual.png" alt="Manual" width="62" height="25" /></a></li>
	</ul>
	</div>
</div>

<div id="content">
	<h1>Actionの実装デザイン</h1>
	<p>
		LastaFluteからの提案です。
	</p>
	<div class="relatedpage"><a href="../../index.html">LastaFluteトップページ</a></div>
	<div class="relatedpage"><a href="../../tutorial/laimpl.html">LastaFluteの実装チュートリアル</a></div>
	<ul class="indexlist">
		<li><a href="#overview">いきなりまとめ</a></li>
		<li><a href="#actionrole">Actionの役割</a>
			<ul>
				<li><a href="#boundaryfacade">バウンダリ、かつ、ファサード</a></li>
				<li><a href="#ifnotx">もし、トランザクションがなければ</a></li>
				<li><a href="#byconvention">規約ベースなので Action は自然分離</a></li>
			</ul>
		</li>
		<li><a href="#actionimpl">Actionに何を実装するか？</a>
			<ul>
				<li><a href="#flowcontrol">フローコントロール <span class="frm">(ファサード)</span></a></li>
				<li><a href="#nonrecyledb">再利用しない検索や更新 <span class="frm">(ちょこっとロジック)</span></a></li>
				<li><a href="#actionlikethis">つまりこんな感じです</a></li>
				<li><a href="#whererecycle">検索の再利用は部品単位で</a></li>
			</ul>
		</li>
		<li><a href="#logicimpl">Logicに何を実装するか？</a>
			<ul>
				<li><a href="#recylelogic">再利用するものだけをロジックに！</a></li>
				<li><a href="#looselogic">ルーズなロジックだと？</a></li>
				<li><a href="#firstlogic">二個目が見えてないときは難しい</a></li>
				<li><a href="#lazyrecyle">再利用するときに切り出せばいい</a></li>
			</ul>
		</li>
		<li><a href="#nologicweb">No more, Logic が WEB に依存!?</a></li>
		<li><a href="#nologicaction">No more, Logic が Action 継承!?</a></li>
		<li><a href="#nologicaction">No more, アバウトLogic!?</a></li>
		<li><a href="#nomorecaossuper">No more, ごちゃごちゃスーパークラス</a></li>
		<li><a href="#nomorecaosref">No more, あっちらこっちら参照</a></li>
		<li><a href="#actionassist">ActionをアシストするActionAssist</a>
			<ul>
				<li><a href="#easywebclass">WEB依存でちょこっとまとめたい</a></li>
				<li><a href="#assistpackage">Assistクラスのパッケージ</a></li>
				<li><a href="#assistknowweb">AssistクラスはWEBに依存してOK</a></li>
				<li><a href="#assistknowfront">Assistクラスは画面に依存してOK!?</a></li>
				<li><a href="#assistcandi">Assistクラスも普通にDIできる</a></li>
				<li><a href="#suppressweblogic">WEBに依存したロジックを作らないためにも</a></li>
				<li><a href="#suppressweblogic">チグハグなスーパークラスを作らないためにも</a></li>
			</ul>
		</li>
	</ul>

	<h2 id="overview">いきなりまとめ</h2>
	<p>
		本気でDDDをやるフェーズまで達していない段階、かつ、プロジェクトで独自にアーキテクチャを定義していない場合の、LastaFlute
		からのデフォルト実装デザインの提案です。
	</p>
	<dl class="textlist">
		<dt><em class="mark">Action</em> <span class="frm">(すでにトランザクションかかっている)</span></dt>
		<dd><em class="keyword">フローコントロール、再利用しない検索や更新 (ちょこっとロジック) を書く</em></dd>
		<dd>検索の再利用は部品単位で <span class="frm">(ArrangeQueryを積極活用)</span></dd>
		<dd>WEB依存 "する" 処理を再利用したいときは <em class="mark">ActionAssist</em></dd>
		<dd>WEB依存 "しない" ビジネスロジックを再利用したいときは <em class="mark">Logic</em></dd>
		<dt><em class="mark">Logic</em> <span class="frm">(ビジネスロジック)</span></dt>
		<dd><em class="keyword">再利用するものだけロジックに書く</em> <span class="frm">(二箇所以上で呼ばれて初めて Logic に)</span></dd>
		<dd>WEB依存しないようにキープ <span class="frm">(Formを渡したりしない、Sessionは参照しない)</span></dd>
		<dd>Actionを継承してはいけない <span class="frm">(当たり前ですが...)</span></dd>
		<dd>Logicの名前は、モノ+Logic はダメ、"モノ+業務+Logic" or "業務+Logic"</dd>
	</dl>

	<h2 id="actionrole">Actionの役割</h2>
	<h3 id="boundaryfacade">バウンダリ、かつ、ファサード</h3>
	<p>
		Action には、<em class="keyword">すでにトランザクションがかかっています</em>。
		単なるWebサイドのバウンダリ(境界)としての役割だけでなく、<em class="keyword">ビジネスロジックのファサード(玄関)としての役割</em> を持つことができます。
	</p>
	<p>
		厳密なアーキテクチャではその役割を分離することが多いですが、LastaFlute ではシンプルさを追求するために、一つにしています。
		スタートアップの開発では、その二つを分離することのメリットを享受する前に変更がたくさん入り、逆に分離していることによるデメリットが足かせになりやすいと考えます。
	</p>
	<h3 id="ifnotx">もし、トランザクションがなければ</h3>
	<p>
		例えば、とある Action では、A という処理と B という処理と C という処理を行う必要があるとします。
		もし、Actionにトランザクションがかかっていなければ、通常は A, B, C を呼び出す流れのロジックは Action には書けません。
		A と B で insert や update をしたとき、C で例外が発生しても A と B をロールバックできないからです。
	</p>
	<p>
		ゆえに、トランザクションを発行させるビジネスロジックのファサードのようなレイヤ<span class="frm">(様々な呼ばれ方をします)</span>を用意して、Actionはそこに委譲することが多いです。
		ですが、そこで迷うのが、じゃあそのレイヤはどこまで依存していいのか？Formを引数で渡してもいいのか？何かしらのDTOに詰め替えをして渡す？
		様々なデザインが存在します。しっかり決め事をしないとどんどん実装はバラバラになります。 
	</p>
	<p>
		LastaFluteでは、そのデザインをする必要性がスタートアップではあまりないだろうと考え、Action でそれをまかなえるようにしています。
		少なくとも、わざわざ Form の値を DTO に詰め替えて、すぐ隣のクラスに渡すというようなことはスタートアップではあまり意味がないと考えています。
	</p>
	<h3 id="byconvention">規約ベースなので Action は自然分離</h3>
	<p>
		LastaFlute の Action は規約ベースであり、ある意味不自由です。少なくとも、ネストしたURLの Execute
		メソッドを定義することはできません。SeaAction に、/sea/land/piari/ を受け付けるメソッドは作れません。
		ゆえに、Action クラスに定義できるメソッドは限界があり、自然と分離されていきます。規約ベースでないフレームワークの Action
		で、/sea/ 配下の URL のメソッドが大量に一つの SeaAction に実装されて見通しが非常に悪いというようなアンチパターンを見かけますが、
		LastaFluteでは比較的それは発生しづらいことです。 
	</p>
	<p>
		なので、<em class="keyword">Action クラスである程度 "ベタっと" 書くことを許容</em>
		して、逆にそのメリットを享受する方がよいだろうと考えています。
		インクリメンタル開発では、既存のソースコードを読む時間が非常に長いです。あちこち飛ぶのはできるだけ少なくしたいものです。
	</p>

	<h2 id="actionimpl">Actionに何を実装するか？</h2>
	<h3 id="flowcontrol">フローコントロール <span class="frm">(ファサード)</span></h3>
	<p>
		先ほど出てきた "A やって B やって C やって"
		という、そのリクエストにおけるトランザクションに含む必要のある流れの呼び出しを司ります。
	</p>
	<p>
		C で例外が発生しても、A と B がロールバックされるように。
	</p>
	<h3 id="nonrecyledb">再利用しない検索や更新 <span class="frm">(ちょこっとロジック)</span></h3>
	<p>
		ActionでDBアクセスしてはいけないというポリシーは LastaFlute
		には存在しません。少なくとも、プロジェクトポリシーで明確に規定されない限りは。
	</p>
	<p>
		その画面でしか使わない ConditionBean による検索や更新など、Action で入れてもOKです。
	</p>
	<h3 id="actionlikethis">つまりこんな感じです</h3>
	<p>
		シンプルな処理ですが...
	</p>
<pre><span class="codetitle">e.g. SeaLandAction in harbor @Java</span><code>
<span class="comment">/**
 * @author yourname
 */</span>
<span class="keyword">public class</span> SeaLandAction <span class="keyword">extends</span> HarborBaseAction {

    <span class="comment">// ===================================================================================
    //                                                                           Attribute
    //                                                                           =========</span>
    @Resource
    <span class="keyword">private</span> <span class="point">PurchaseBhv</span> <span class="attribute">purchaseBhv</span>;

    <span class="comment">// ===================================================================================
    //                                                                             Execute
    //                                                                             =======</span>
    @Execute
    <span class="keyword">public</span> HtmlResponse index(<span class="keyword">int</span> <span class="localvar">productId</span>, SeaLandForm <span class="localvar">form</span>) {
        validate(<span class="localvar">form</span>, <span class="localvar">messages</span> -&gt; {}, () -&gt; {
            <span class="keyword">return</span> asHtml(<span class="attribute">path_Sea_SeaLandJsp</span>);
        });
        ListResultBean&lt;Purchase&gt; <span class="localvar">purchaseList</span> = selectPurchaseList(<span class="localvar">form</span>);
        List&lt;SeaLandRowBean&gt; <span class="localvar">beans</span> = mappingToBeans(<span class="localvar">purchaseList</span>);
        <span class="keyword">return</span> asHtml(<span class="attribute">path_Sea_SeaLandJsp</span>).renderWith(<span class="localvar">data</span> -&gt; {
            <span class="localvar">data</span>.<span class="subpoint">register</span>(<span class="literal">"beans"</span>, <span class="localvar">beans</span>);
        });
    }

    <span class="comment">// ===================================================================================
    //                                                                              Select
    //                                                                              ======</span>
    <span class="keyword">private</span> ListResultBean&lt;Purchase&gt; selectPurchaseList(SeaLandForm <span class="localvar">form</span>) {
        <span class="keyword">return</span> <span class="attribute">purchaseBhv</span>.selectList(<span class="localvar">cb</span> -&gt; {
            <span class="localvar">cb</span>.setupSelect_Member();
            <span class="localvar">cb</span>.setupSelect_Product();
            <span class="localvar">cb</span>.query().setProductId_Equal(<span class="localvar">productId</span>);
            <span class="localvar">cb</span>.orScopeQuery(<span class="localvar">orCB</span> -> {
                <span class="localvar">orCB</span>.query().setMemberId_Equal(<span class="localvar">userId</span>);
                <span class="localvar">orCB</span>.query().queryMember().existsMemberFollowingByYourMemberId(<span class="localvar">followingCB</span> -> {
                    <span class="localvar">followingCB</span>.query().setMyMemberId_Equal(<span class="localvar">userId</span>);
                });
            });
            <span class="localvar">cb</span>.query().existsPurchasePayment(<span class="localvar">paymentCB</span> -&gt; {
                <span class="localvar">paymentCB</span>.query().setPaymentMethodCode_Equal_AsPaymentMethod(form.<span class="attribute">pay</span>);
            });
            <span class="localvar">cb</span>.query().addOrderBy_PurchaseDatetime_Desc();
        });
    }

    <span class="comment">// ===================================================================================
    //                                                                             Mapping
    //                                                                             =======</span>
    <span class="keyword">private</span> List&lt;SeaLandRowBean&gt; mappingToBeans(ListResultBean&lt;Purchase&gt; <span class="localvar">purchaseList</span>) {
        <span class="keyword">return</span> <span class="localvar">purchaseList</span>.mappingList(<span class="localvar">purchase</span> -&gt; {
            SeaLandRowBean <span class="localvar">bean</span> = <span class="keyword">new</span> SeaLandRowBean();
            <span class="localvar">bean</span>.<span class="attribute">purchaseId</span> = <span class="localvar">purchase</span>.getPurchaseId();
            <span class="localvar">purchase</span>.getMember().alwaysPresent(<span class="localvar">member</span> -&gt; {
                <span class="localvar">bean</span>.<span class="attribute">memberName</span> = <span class="localvar">member</span>.getMemberName();
            });
            <span class="localvar">purchase</span>.getProduct().alwaysPresent(<span class="localvar">product</span> -&gt; {
                <span class="localvar">bean</span>.<span class="attribute">productName</span> = <span class="localvar">product</span>.getProductName();
                <span class="localvar">bean</span>.<span class="attribute">productHandleCode</span> = <span class="localvar">product</span>.getProductHandleCode();
            });
            <span class="localvar">bean</span>.purchaseDate = toStringDate(<span class="localvar">purchase</span>.getPurchaseDatetime()).get();
            <span class="localvar">bean</span>.purchasePrice = <span class="localvar">purchase</span>.getPurchasePrice();
            <span class="keyword">return</span> <span class="localvar">bean</span>;
        });
    }
}
</code></pre>
	<h3 id="whererecycle">検索の再利用は部品単位で</h3>
	<p>
		もし、検索の中で再利用したいものがあれば、<em class="keyword">Arrange Query</em>
		を使いましょう。これは、DBFluteのポリシーでもあります。検索の丸ごと再利用は多くの場合失敗に終わります。
	</p>
	<div class="detailpage"><a href="http://dbflute.seasar.org/ja/manual/function/genbafit/implfit/whererecycle/">where句の再利用</a></div>

	<h2 id="logicimpl">Logicに何を実装するか？</h2>
	<p>
		Logicは、非常に粒度を設計するのが難しいクラスです。画面単位？テーブル単位？いやいや業務単位？
		しっかりとDDDをやらない限り、業務単位というのもなかなか適切なデザインをするのは難しいです。
	</p>
	<h3 id="recylelogic">再利用するものだけをロジックに！</h3>
	<p>
		ここはなかなか答えを出すのが難しいところですが、LastaFluteでのひとつの提案があります。
	</p>
	<p>
		<em class="keyword">☆☆☆ 再利用するものだけロジックに書く ☆☆☆</em>
	</p>
	<p>
		再利用し過ぎるよりかは、少し足りないくらいの方がスタートアップには向いていると考えます。
	</p>
	<h3 id="looselogic">ルーズなロジックだと？</h3>
	<p>
		曖昧なまま、Logic運用をするプロジェクトがたくさんあります。
		そこで発生する問題は大抵同じです。
	</p>
	<dl class="textlist">
		<dt>潜在的に画面に依存したロジック</dt>
		<dd>
			汎用的に見えて、実際には (潜在的に) 固有の画面に依存したロジック。再利用すべきでないロジック。
		</dd>
		<dd>
			これ自体が悪いというより、これが Logic に入っていると、ついつい別の画面が使ってしまうことがあります。
			そうすると、元々の画面のロジック変更をしたとき、別の画面に不具合が発生する可能性があります。
			ちゃんと修正するときに確認はすべきことですが、ロジックの扱いが曖昧だと、修正する方は他の画面が使ってると全く思わず作業してしまいます。
		</dd>
		<dd>
			そうなってくると、本来再利用すべきロジックも "なんか怖くて呼べない", "呼んでいいのやらいけないのやら..."
			という気持ちになってきて、本来ロジックが持っている大きな役割の一つである "再利用"
			に支障が出てくるのです。
		</dd>
		<dt>ソースを読むのにあっちこっち飛ぶ</dt>
		<dd>
			そもそも再利用していたり、業務上の意味が明確で、ネーミングもわかりやすいものであれば、それは問題ないですが、
			なかなかそうはならないです。たくさん command + click
			でソースを飛んで飛んで読んでいても、実際には全部その画面固有の処理だったなんてことも...
		</dd>
		<dd>
			綺麗に役割を分けて書くというのは、想像以上に難しいことです。プログラムが書けるからそれができる、とは全く言えないと考えます。
			ヘタに分けるくらいだったら、分けない方がまだマシというようなことも多くあります。
		</dd>
	</dl>
	<h3 id="firstlogic">二個目が見えてないときは難しい</h3>
	<p>
		将来の再利用を目的に Logic に切り出すとします。厳密にはそれはとてもよいことです。
		しかしながら、そのときはまだ再利用するもう一個のリクエストが見えてない状態です。
		その状態で二個目のリクエストに本当にぴったりな再利用メソッドに最初から仕上げるのはなかなか高度なことです。
	</p>
	<p>
		よくあるケースで、"再利用できそうなんだけど、ちょっとだけ違うんだよね"
		と、実質最初のプロセス固有の処理が入り込んでしまったりして、結局再利用できないことも。
		すると、ここでなかなかつらいことが発生します。
	</p>
	<dl class="valuemainlist">
		<dt>コピペパターン</dt><dd>コピーして、少しだけ直したものを新しく作ってしまう</dd>
		<dt>リモコンパターン</dt><dd>一つ目のメソッドの引数にbooleanを追加して分岐させる</dd>
	</dl>
	<p>
		放っておくと大抵はコピペパターンになります。
	</p>
	<p>
		リモコンパターンが積み重なると、悲劇を生みます。
	</p>
	<div class="detailpage"><a href="http://dbflute.seasar.org/ja/manual/function/genbafit/implfit/whererecycle/#argremote">引数リモコンパターンはやめたい</a></div>
	<p>
		単純に処理の違いだけでなく、引数や戻り値などのメソッドデザインが、二個目のリクエストに合うとも限りません。
		二個目の人にとっては使いづらくて、結局使わないで自分で書いたり、先ほどのパターンにハマったりすることも多いです。
	</p>
	<h3 id="lazyrecyle">再利用するときに切り出せばいい</h3>
	<p>
		インクリメンタル開発は、運用中の既存のコードを修正するのが当たり前なので、ある意味で既存のコードを修正しやすい環境とも言えます。
		なので、適切な再利用が見えてきてから再利用をするように切り出すことは比較的しやすいのです。
	</p>
	<p>
		もちろん、再利用メソッドの経験値の高い人はよいですが、そうでないならば、将来を見越した再利用メソッドは無理をする必要はないと考えます。
		なので、ひとまずは Action クラスに書いてもいいでしょうと。それが恒久デザインなわけではないので。
	</p>
	<p>
		もし、自信持って再利用メソッドをあらかじめ作るのであれば、JavaDocなどはしっかり整備して、再利用する人が迷わないようにしましょう。
	</p>

	<div class="inucolumn">
		<h2 id="nologicweb">No more, Logic が WEB に依存!?</h2>
		<p>
			もっと、"それ以前" 的な話ですが...
			時々見かけるコードにこういうのがあります。
		</p>
<pre><span class="codetitle">e.g. No way, logic should not depend on web @Java</span><code>
<span class="keyword">public class</span> SeaInParkLogic {

    <span class="keyword">public void</span> land(<span class="point">SeaForm</span> form) { <span class="comment">// ★絶対ダメ</span>
    }
}
</code></pre>
		<p>
			先の通り、<em class="keyword">Logicは再利用を目的</em> にしているため、とある固有の画面のFormクラスを参照すると、別の画面で再利用がしづらくなります。
			FormクラスはWEBサイドに特化しているので、こちらも先に述べた潜在的にWEBに依存したロジックとなってしまいます。
		</p>
		<p>
			仮に、B画面がA画面のFormをnewして無理矢理再利用したとしましょう。
			でも、A画面のFormはA画面に最適化されていて、いかにもA画面だけで使っていそうなクラス名やパッケージに見えます。
			でも実はB画面が使っている...となると、<em class="keyword">B画面やLogicのことを気にせずにA画面都合の修正が入り、B画面やLogicが落ちる</em>
			というトラブルが発生しやすくなります。ひとりで作っていればそんなことはないだろうと思われるかもしれませんが、インクリメンタル開発では様々な人が入れ替わり立ち替わりコードを修正することが想定されるため、再利用すべきもの再利用すべきでないものは明確にしたいという気持ちがあります。
		</p>
		<p>
			アーキテクチャ的にも、完全に逆参照となります。
		</p>
		<div class="relatedpage"><a href="../../tutorial/laimpl.html#architecture">アーキテクチャ概念マップ</a></div>
		<p>
			どうしても引数が多くてまとめたい場合は、別途パラメータークラスを作成すると良いでしょう。
		</p>
<pre><span class="codetitle">e.g. Parameter class for SeaInPark @Java</span><code>
<span class="keyword">public class</span> SeaInParkParam {

    <span class="keyword">public</span> Integer piariId;
    <span class="keyword">public</span> String dstoreName;
    <span class="keyword">public</span> LocalDate bonvoDate;
    <span class="keyword">public</span> LocalDateTime ambaDateTime;
    <span class="keyword">public</span> Boolean miraco;
    <span class="abbreviation">...</span>
}
</code></pre>
<pre><span class="codetitle">e.g. Logic accepts Param @Java</span><code>
<span class="keyword">public class</span> SeaInParkLogic {

    <span class="keyword">public void</span> land(SeaInParkParam param) {
    }
}
</code></pre>
<pre><span class="codetitle">e.g. package of parameter class @Directory</span><code>
app
 |-logic
 |  |-sea
 |  |  |-SeaInParkLogic.java
 |  |  |-<span class="point">SeaInParkParam.java</span>
 |-web
 |  |-sea
 |  |  |-SeaAction.java
 |  |  |-SeaForm.java
</code></pre>
		<p>
			概念的な話が難しければ、<em class="keyword">app.logicパッケージからapp.webパッケージを参照してしまっていないか？</em>
			という視点で考えて頂ければと。
		</p>
		<p>
			Logicは、ずばり <em class="mark">ビジネスロジック</em> ということで、極端な話 "バッチのプログラムから呼ばれても大丈夫"
			というような状態をキープするものです。少なくとも、LastaFluteではそのように想定しています。
			なので、Session や Cookie にも依存してはいけません<span class="frm">(SessionManager や CookieManager を DI してはいけません)</span>。
		</p>
<pre><span class="codetitle">e.g. No way, logic should not depend on web @Java</span><code>
<span class="keyword">public class</span> SeaInParkLogic {

    @Resource
    <span class="keyword">private</span> RequestManager requestManager; <span class="comment">// ★絶対ダメ</span>
    @Resource
    <span class="keyword">private</span> SessionManager sessionManager; <span class="comment">// ★絶対ダメ</span>
    @Resource
    <span class="keyword">private</span> CookieManager cookieManager; <span class="comment">// ★絶対ダメ</span>
}
</code></pre>
		<p>
			どうしても、WEBに依存した状態で再利用がしたければ、それは ActionAssist を使いましょう。
		</p>
		<div class="detailpage"><a href="#actionassist">this - ActionをアシストするAssistクラス</a></div>
	</div>

	<div class="inucolumn">
		<h2 id="nologicaction">No more, Logic が Action 継承!?</h2>
		<p>
			よく新人プログラマーの実装で見かけることがあるかと思います。
		</p>
<pre><span class="codetitle">e.g. No way, logic should not extend action @Java</span><code>
<span class="keyword">public class</span> SeaInParkLogic <span class="keyword">extends</span> DocksideBaseAction { <span class="comment">// ★絶対ダメ</span>
    <span class="abbreviation">...</span>
}
</code></pre>
		<p>
			<em class="keyword">Logic は Action ではありません。</em>つまり、<em class="mark">"is a" の関係</em>になっていません。 
		</p>
		<p>
			では、なぜ "is a" の関係になっていないといけないのでしょうか？
		</p>
		<p>
			Actionのスーパークラスは、Actionに最適化しています。Actionを形づけるために存在しています。
			<em class="keyword">Logicのために存在しているわけではない</em> のです。
		</p>
		<p>
			ゆえに...
		</p>
		<p>
			<em class="keyword">(Actionを継承している)Logicに都合の悪い修正が平気で入ります</em>。
		</p>
		<p>
			もし、Actionのスーパークラスの修正で、それを継承している Logic
			が落ちたとしたら、Action を継承している Logic の方が良くないと言えます。
		</p>
		<p>
			もともとオブジェクト指向の目的として、<em class="bigmark">意味</em>
			を重視して、概念ごとにクラスを取り扱うことでプログラムを整備しやすいという点があります。
			"XxxLogic は Action である" と自然言語にして <em class="keyword">しっくりくるかどうか？</em>
			ここがポイントです。
		</p>
		<p>
			便利なメソッドが欲しければ、Logicがその便利なクラスに依存すればよいと考えます。
			それが、Actionのスーパークラスにベタッと書いてあったのであれば、別途クラスに抽出して再利用して使うようにしましょう。
		</p>
		<p>
			一方で、Logicのスーパークラスを作っても悪いわけではありませんが、スーパークラスのメインの役割は <em class="bigmark">その概念を形づける</em>
			なので、特に Logic を共通的に形づけるものはあまりないかなと考えるので<span class="frm">(Actionが非常に定型的で特殊と言えます)</span>、大抵の場合は全体共通のスーパークラスはあまり必要ではないと考えています。
			もちろん、まとまった業務単位で必要であれば作っても良いでしょう。
		</p>
	</div>

	<div class="inucolumn">
		<h2 id="nologicaction">No more, アバウトLogic!?</h2>
		<p>
			よく巨大な Logic を見かけませんか？
		</p>
<pre><span class="codetitle">e.g. No way, logic should not extend action @Java</span><code>
<span class="keyword">public class</span> SeaLogic { <span class="comment">// ★名前がアバウト</span>

    <span class="comment">// ここにメソッド100個くらい...ってちょっとおおげさだけど、ちょーたくさん</span>
}
</code></pre>
		<p>
			大抵、MemberLogic, ProductLogic というアバウトな名前のクラスであることが多いです。
			Memberに関するLogicだから、Memberに関するものがなんでも入ります。
		</p>
		<p>
			こういったクラスがすでに存在していると、後から実装する人は、当然 Member
			に関するものは MemberLogic に入れます。"ちょっとでかいなぁ、やだなぁ"
			と思っても、そのまま MemberLogic に入れることがほとんどでしょう。MemberLogic
			がすでにあるのに、MemberSignupLogic は作りづらいですから。
			<span class="frm">(すでにあるクラスに入れる方が楽と思うでしょうし...MemberLogicに入れなきゃいけないんだと思うでしょう)</span>
		</p>
		<p>
			Logicはどういう単位で作っていくべきでしょうか？
		</p>
		<p>
			これは難題です。恐らくちゃんとやるなら、DDD的なアプローチが必要になるでしょう。
			でも、スタートアップではなかなか最初から徹底するのは難しいものです。
		</p>
		<p>
			でも、Logicを作って再利用はしたい...
		</p>
		<p>
			少なくとも、<em class="keyword">モノ + Logic だけのクラスは作らないこと</em>。そう、MemberLogic です。
		</p>
		<p>
			小さな提案、最低限 <em class="bigmark">モノ + 業務 + Logic</em> にすること。
			MemberSignupLogic です。もし、業務自体で暗黙にモノが特定できるなら、<em class="mark">業務 + Logic</em>
			だけでも良いでしょう。SignupLogic ですね。でも、モノ+Logicにはしない。
		</p>
<pre><span class="codetitle">e.g. object + business + logic @Java</span><code>
<span class="keyword">public class</span> SeaInParkLogic { <span class="comment">// SeaにInParkするLogic</span>

    <span class="comment">// したら、さすがに In する以外のメソッドが追加されることは...あまりないはず</span>
}
</code></pre>
		<p>
			PurchaseLogic は迷いますね。Purchaseはモノなのか業務なのか...
			でも、購入というイベントにも色々なものがあるかと思います。
			購入フロー自体に加えて、購入商品の支払い、購入履歴の確認、購入のキャンセルなどなど、購入というデータに対して、様々な振舞いが存在します。
			安易に PurchaseLogic を作ると、それらがすべて後からどんどん追加されていきます。
		</p>
		<p>
			その結果、一つしかメソッドがLogicができるかもしれませんが、別にそれは構わないかと思います。
			インクリメンタル開発では、後で追加される可能性は大ですから。
		</p>
		<p>
			<em class="keyword">モノは名詞とは限らないし、業務が動詞とは限りません。</em>
			そこが難しいのかもしれませんが、少なくとも Logic を作るときにちょっと考えてみると、良い名前が見つかるかもしれません。
		</p>
	</div>

	<div class="inucolumn">
		<h2 id="nomorecaossuper">No more, ごちゃごちゃスーパークラス</h2>
		<p>
			BaseAction にどんどん業務メソッドが追加されていくという現象があります。
		</p>
<pre><span class="codetitle">e.g. No way, many business methods in super class @Java</span><code>
<span class="keyword">public abstract class</span> MaihamaBaseAction <span class="keyword">extends</span> <span class="abbreviation">...</span> {

    <span class="comment">// ★どかどか業務メソッドが追加されていく。。。</span>
}
</code></pre>
		<p>
			<em class="keyword">スーパークラスの役割は、その概念を形づけること</em>
		</p>
		<p>
			ある程度、便利メソッドの入り口になる役割として使ってしまうこともありますが、<em class="keyword">それは特定の業務に(できるだけ)依存せず、Actionとしての役割を支援するもの</em>
			に限ります。あくまで、フレームワークとしての役割を担う場所がスーパークラスです。
		</p>
		<p>
			ですが、スーパークラスというもの、特に Action のスーパークラスは目の前にあり、手軽に全体に影響させることのできるものです。
			ついついサクッとメソッドを追加してしまいがちです。
		</p>
		<p>
			WEB依存のLogicを作らないとなると、WEB依存の処理を再利用したいとなると、確かにどこに？という感じになるかもしれません。
			そこで、ActionAssist です。
		</p>
		<div class="detailpage"><a href="#actionassist">this - ActionをアシストするActionAssist</a></div>
		<p>
			それでも、"スーパークラスにあってもいいかなぁ" と思うような処理があったとします。
			メソッド追加する前にひとつ質問 <em class="keyword">そのメソッドを利用する Action って特定できますか？</em>
			できるのであれば、やっぱりAssistクラスでしょう。
		</p>
	</div>

	<div class="inucolumn">
		<h2 id="nomorecaosref">No more, あっちらこっちら参照</h2>
		<p>
			インクリメンタルでよく発生する問題は、"A画面を直したら気付いたらB画面が動かなくなっている"
			というような間接デグレです。スタートアップではある程度そのリスクは覚悟する必要はありますが、安易に起きるのもつらいものです。
		</p>
		<p>
			そのよくある二つの典型的なパターン、まず一つ目...
		</p>
		<p>
			<em class="keyword">再利用できるレイヤに(本来)再利用できないメソッドが定義されている</em> というパターン。
			例えば、Logic に実質的潜在的にA画面に依存したメソッドがあると、Logicは再利用メソッドを置く領域なので、B画面がついつい使ってしまうかもしれません。
			でも、A画面のディベロッパーは知らずにA画面の都合で修正してしまうでしょう。A画面のActionで書くべき、もしくは、もっと細かい部品単位で再利用するようにすべきでしょう。
			これは Logic に何を書くべきか？をさんざんこのページで議論してきましたのでここでは話はおしまい。
		</p>
		<p>
			ということで、二つ目がポイントです。
		</p>
		<p>
			<em class="keyword">A画面専用のクラスっぽい風貌なのに、実はB画面からも使われている</em>
			というパターン。
		</p>
		<p>
			例えば、SeaAction に対する SeaForm クラスがあったとして、パッケージも sea の下、なのに、land
			パッケージの LandAction で SeaForm が使われているようなケース。
		</p>
<pre><span class="codetitle">e.g. stileto reference @Directory</span><code>
app
 |-web
 |  |-sea
 |  |  |-SeaAction.java
 |  |  |-<span class="subpoint">SeaForm.java</span>
 |  |-land
 |  |  |-LandAction.java <span class="comment">// use SeaForm</span>
</code></pre>
		<p>
			ディベロッパーとしては、直したらIDEの機能を使うなりしてクラスの参照を辿って影響範囲を特定すべきところですが、スタートアップの現場ではなかなかそれを徹底させることは現実的には難しいもので、
			いかにも共通っぽいクラスであればまだディベロッパーは気をつける意識が強くなりますが、A画面専用っぽい見た目をしていたらなかなか見逃してしまいます。
		</p>
		<p>
			もうその場合は、そういう <em class="keyword">不意打ちのような再利用</em> をした方が良くないと言えるでしょう。
		</p>
		<p>
			ひとつ提案です。以下のようなポリシーでクラス作りをしてみてはいかがでしょう？
		</p>
		<ul>
			<li><em class="smallmark">app.web.[業務固有のパッケージ]</em> から、他の業務固有のパッケージのクラスは参照しない</li>
			<li>WEB依存のものを再利用するなら <em class="mark">app.web.base.[再利用業務パッケージ]</em> に置く</li>
			<li><em class="smallmark">app.web.[業務固有のパッケージ]</em> の同じパッケージ(サブ含む)なら参照してもOK</li>
			<li>もちろん、ビジネスロジックとして再利用できるなら Logic にする</li>
		</ul>
<pre><span class="codetitle">e.g. use base for recycle @Directory</span><code>
app
 |-web
 |  |-<span class="point">base</span>
 |  |  |-<span class="subpoint">sea</span> <span class="comment">// rename if better name exists</span>
 |  |  |  |-<span class="subpoint">SeaForm</span>
 |  |  |-MaihamaBaseAction
 |  |  |-<span class="abbreviation">...</span>
 |  |-sea
 |  |  |-SeaAction <span class="comment">// use base.sea.SeaForm</span>
 |  |-land
 |  |  |-LandAction <span class="comment">// use base.sea.SeaForm</span>
 |  |-piari
 |  |  |-dstore
 |  |  |  |-PiariDstoreAction <span class="comment">// use PiariForm</span>
 |  |  |-PiariDetailAction <span class="comment">// use PiariForm</span>
 |  |  |-PiariEditAction <span class="comment">// use PiariForm</span>
 |  |  |-<span class="subpoint">PiariForm</span> <span class="comment">// cane be recycled in same package</span>
</code></pre>
		<p>
			なかなか厳密にやるのは難しいのですが、できるだけ...
		</p>
		<p>
			<em class="keyword">再利用されないクラスと再利用されるクラスを明確にわけることが大切だと考えます。</em>
		</p>
	</div>

	<h2 id="actionassist">ActionをアシストするActionAssist</h2>
	<h3 id="easywebclass">WEB依存でちょこっとまとめたい</h3>
	<p>
		Assistクラスは、単なるActionのアシストです。
	</p>
<pre><span class="codetitle">e.g. Assist class @Java</span><code>
<span class="keyword">public class</span> SeaAssist {

    <span class="abbreviation">...</span>
}
</code></pre>
	<p>
		<em class="keyword">WEBや画面に依存してるので Action の中で記述するべきものだけど、ちょこっとまとまったクラスにしたい</em>
		というときに使います。
	</p>
	<ul>
		<li>Actionの中のprivateメソッドがでかくなってきたので、ちょっと外に出したい</li>
		<li>WEB依存した処理を、A画面とB画面でちょっと再利用したい</li>
	</ul>
	<p>
		そういうときに作ります。
	</p>
	<h3 id="assistpackage">Assistクラスのパッケージ</h3>
	<p>
		再利用しないなら、その Assist を使う Action クラスの隣でいいかと思います。
	</p>
<pre><span class="codetitle">e.g. package of no-recycled assit class @Directory</span><code>
app
 |-web
 |  |-sea
 |  |  |-SeaAction.java <span class="comment">// use SeaAssist</span>
 |  |  |-<span class="point">SeaAssist.java</span>
 |  |  |-SeaForm.java
</code></pre>
	<p>
		再利用するのであれば web.base パッケージに、任意のパッケージを作って再利用すると良いでしょう。
	</p>
<pre><span class="codetitle">e.g. package of recycled assit class @Directory</span><code>
app
 |-web
 |  |-base
 |  |  |-maihama
 |  |  |  |-<span class="point">ResortAssist.java</span>
 |  |-sea
 |  |  |-SeaAction.java <span class="comment">// use ResortAssist</span>
 |  |  |-SeaForm.java
 |  |-land
 |  |  |-LandAction.java <span class="comment">// use ResortAssist</span>
 |  |  |-LandForm.java
</code></pre>
	<h3 id="assistknowweb">AssistクラスはWEBに依存してOK</h3>
	<p>
		RequestManager や SessionManager や CookieManager などガッツリ使ってOKです。
		どちらかというと、そういったWEBに絡んだ処理を再利用するためのものと言えるでしょう。
	</p>
	<h3 id="assistknowfront">Assistクラスは画面に依存してOK!?</h3>
	<p>
		画面に依存していいいかどうかは、再利用するのかどうか次第です。
	</p>
	<p>
		再利用しない Assist であれば、べったり呼び出し元の Action に依存させてOKです。
		つまり、FormクラスやBodyクラスも参照しちゃってOKです。パッケージ的にも不自然ではありません。
		この場合の Assist の役割は、単に Action で書くのがちょっと量が多いので外に出すという感じですね。
	</p>
	<p>
		再利用する Assist であれば、もちろんとある固定の画面に依存することはできませんが、
		例えば Form や Body 自体を再利用しているとかであれば<span class="frm">(その場合、Form や Body も base パッケージに)</span>、
		その Form や Body を Assist から参照しても良いでしょう。
	</p>
	<h3 id="assistcandi">Assistクラスも普通にDIできる</h3>
	<p>
		Actionクラスの中で、普通に DI できます。
	</p>
	<p>
		また Assistクラスの中で、様々なコンポーネントをDIすることもできます。
	</p>
	<h3 id="suppressweblogic">WEBに依存したロジックを作らないためにも</h3>
	<p>
		どうしても、WEBに依存したまとまった処理を再利用したいと考えることがあります。
	</p>
	<p>
		一方で、Action はバウンダリ、かつ、ファサード、Logicには再利用するものだけを記述する、という方式を追求すると、
		それなりに Action には処理が入り込む可能性があります。
	</p>
	<p>
		そうしたとき、ちょっと気軽にWEB依存したままのクラスを作ってしまえばいいなと、Assistがないアーキテクチャで開発していたときに思っていました。
		でも、アーキテクチャにそういう概念がないと、なかなか誰も新しいクラスを作ろうとはしません。
		そのしわ寄せが Logic に行くのです。
	</p>
	<h3 id="suppressweblogic">チグハグなスーパークラスを作らないためにも</h3>
	<p>
		というか、これはチグハグなスーパークラスにさせないためのものでもあります。
		LogicをWEB依存させないようにすると、しわ寄せがスーパークラスに来ます。
	</p>
	<p>
		先の通り、スーパークラスは概念を形づけるためのものです。
		ある程度の便利にするためのメソッドが入り込むのは仕方ないとしても、特定の業務的なものは入れるものところではありません。
	</p>
	<p>
		それなら、ActionAssist を使って、再利用しましょう。
	</p>

</div>
</div>

<div id="sidebar">
	<div class="logo"><a href="../../../../"><img src="../../../../image/parts/logo.png" alt="dbflute-logo" width="240" height="110" /></a></div>
<ul>
		<li><a href="../../../../ja/lastaflute/index.html">LastaFluteトップページ</a>
			<ul>
				<li><a href="../../../../ja/lastaflute/index.html#about">LastaFluteとは？</a></li>
				<li><a href="../../../../ja/lastaflute/index.html#lacode">LastaFluteのコード</a></li>
				<li class="upper-space"><a href="../../../../ja/lastaflute/index.html#quicktrial">動かしてみよう</a></li>
				<li><a href="../../../../ja/lastaflute/index.html#newproject">新プロジェクト</a></li>
				<li><a href="https://github.com/lastaflute/lastaflute">LastaFlute | Github</a></li>
			</ul>
		</li>
		<li><a href="../../../../ja/lastaflute/tutorial/laimpl.html">LastaFlute実装チュートリアル</a>
			<ul>
				<li><a href="../../../../ja/lastaflute/tutorial/laimpl.html#style">実装スタイル</a></li>
				<li><a href="../../../../ja/lastaflute/tutorial/laimpl.html#prepare">まず準備</a></li>
				<li class="upper-space"><a href="../../../../ja/lastaflute/tutorial/laimpl.html#acquaintanceship">ディベロッパーの心得</a></li>
				<li><a href="../../../../ja/lastaflute/tutorial/laimpl.html#tenclause">ディベロッパーの十か条</a></li>
				<li><a href="../../../../ja/lastaflute/tutorial/faqimpl.html">LastaFluteの実装FAQ</a></li>
			</ul>
		</li>
		<li><a href="../../../../ja/lastaflute/howto/action/index.html">LastaFlute の Action</a>
			<ul>
				<li><a href="../../../../ja/lastaflute/howto/action/makeashtml.html">Actionの作り方 (HTML)</a></li>
				<li><a href="../../../../ja/lastaflute/howto/action/lavalidation.html">Validation</a></li>
			</ul>
		</li>
		<li><a href="../../../../ja/lastaflute/lastadi/index.html">Lasta Diトップページ</a>
			<ul>
				<li><a href="../../../../ja/lastaflute/lastadi/index.html#twocomp">Two Components</a></li>
				<li><a href="../../../../ja/lastaflute/lastadi/dixmlexp.html">Di xml の表現</a></li>
				<li><a href="https://github.com/lastaflute/lasta-di">Lasta Di | Github</a></li>
			</ul>
		</li>
		<li><a href="../../../../ja/tutorial/onjava8.html">DBFlute on Java8</a>
			<ul>
				<li><a href="../../../../ja/tutorial/onjava8.html#select">とにかく検索は？</a></li>
				<li><a href="../../../../ja/tutorial/onjava8.html#completion">さあ、補完してみよう！</a></li>
			</ul>
		</li>
	</ul>

</div>

<div id="footer">
	<div><a href="../../../../ja/sitemap.html">SiteMap</a> <a href="http://d.hatena.ne.jp/jflute">Author's Blog</a><a href="https://www.seasar.org/issues/browse/DBFLUTE">BTS</a></div>
	<ul class="footer-navi">
		<li class="hd-introduction"><a href="../../../../ja/introduction/index.html">Introduction</a></li>
		<li class="hd-tutorial"><a href="../../../../ja/tutorial/index.html">Tutorial</a>
			<ul>
				<li class="hd-architect"><a href="../../../../ja/tutorial/architect.html">for Architect</a></li>
				<li class="hd-developer"><a href="../../../../ja/tutorial/developer.html">for Developer</a></li>
			</ul>
		</li>
		<li class="hd-environment"><a href="../../../../ja/environment/index.html">Environment</a>
			<ul>
				<li class="hd-install"><a href="../../../../ja/environment/setup/index.html">Setup</a></li>
				<li class="hd-upgrade"><a href="../../../../ja/environment/upgrade/index.html">Upgrade</a></li>
			</ul>
		</li>
		<li class="hd-manual"><a href="../../../../ja/manual/index.html">Manual</a></li>
	</ul>

</div>

</div>
</body>
</html>
