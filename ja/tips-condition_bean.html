<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- don't edit start -->
<head>
<title>Seasar - DI Container with AOP - </title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<link href="seasar_b.css" type="text/css" rel="stylesheet" media="screen" />
<link href="seasar_p.css" type="text/css" rel="stylesheet" media="print" />
<script src="seasar_b.js" type="text/JavaScript" language="JavaScript"></script>
</head>
<body onload="preload('ja')">
<table width="100%" border="0" cellspacing="0" cellpadding="0" align="left"><tr>
<td align="left" valign="top" width="780"><table width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr><td colspan="7"><img height="5" width="780" src="images/top01_b.gif" alt=""></td></tr>
<tr><td><img height="117" width="235" src="images/top02_b.gif" alt="Seasar"></td>
<td colspan="3"><img height="117" width="289" src="images/top03.gif" alt="DI Container with AOP"></td>
<td colspan="3"><img height="117" width="256" src="images/spacer.gif" alt=""></td>
</tr><tr><td rowspan="2"><img src="images/top04.gif" alt="" height="49" width="235"></td>
<td><a href="http://www.seasar.org/index.html"><img src="images/menu01_b_ja.gif" height="30" width="78" border="0" alt="" id="menu01" onmouseover="swap(1)" onmouseout="restore(1)"></a></td>
<td><a href="http://www.seasar.org/projects.html"><img src="images/menu02_b_ja.gif" height="30" width="101" border="0" alt="" id="menu02" onmouseover="swap(2)" onmouseout="restore(2)"></a></td>
<td><a href="http://www.seasar.org/products.html"><img src="images/menu03_b_ja.gif" height="30" width="110" border="0" alt="" id="menu03" onmouseover="swap(3)" onmouseout="restore(3)"></a></td>
<td><a href="http://www.seasar.org/resources.html"><img src="images/menu04_b_ja.gif" height="30" width="113" border="0" alt="" id="menu04" onmouseover="swap(4)" onmouseout="restore(4)"></a></td>
<td><img src="images/menu05_b_ja.gif" height="30" width="109" border="0" alt="" id="menu05" onmouseover="swap(5)" onmouseout="restore(5)"></td>
<td><img height="30" width="34" src="images/menu06.gif" alt=""></td></tr><tr>
<td colspan="6"><img height="19" width="545" src="images/spacer.gif" alt=""></td></tr></table>
<table  width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr align="left" valign="top"><td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td><td width="740" class="main">
<!-- don't edit end -->
<!-- document start -->
<p>
<a href="index.html">to Top</a>
<p><b>
ConditionBeanの利用方法を記述します。
<p></b>
<pre>


// ======================================================================================================
//                                                                                          ConditionBean
//                                                                                          =============

// ---------------------------------------------------------
//                                    What is ConditionBean?
//                                    ----------------------

S2Daoの「DTO引数によるSQL自動生成機能」を拡張し、SQL自動生成の幅を広げたもの。



// ---------------------------------------------------------
//                          Why is condition-bean necessary?
//                          --------------------------------

S2Daoはとても素晴らしいものですが、実利用には幾つか課題を残します。
  →詳しくは、<a href="./introduction.html">作者からのIntroduction</a> をご覧下さい。



// ---------------------------------------------------------
//                                        What policy is it?
//                                        ------------------

ConditionBeanのPolicyについては、<a href="./condition_bean_policy.html">ConditionBean Policy</a> をご覧下さい。



// ---------------------------------------------------------
//                             What has been enhanced to it?
//                             -----------------------------
<a href="http://dbflute.sandbox.seasar.org/ldb/erd/index.html">
<img height="340" width="720" src="images/dbflute_ldb_text_erd.jpg" alt="">
</a>

    1. Where句に指定する条件で{=}以外の演算子もサポート

        {=, &gt;, &lt;, &gt;=, &lt;=, Like, is null, is not null, in(), not in()}
        全てAND条件によって接合される。

        ex) BOOKに対してBOOK_NAMEの'S2Dao'前方一致で、かつ、GENRE_CODEがnullでないものを検索
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // select ...
        //   from BOOK book
        //  where book.BOOK_NAME like 'S2Dao%'
        //    and book.GENRE_CODE is not null
        // 
        final LdBookCB cb = new LdBookCB();
        <b>cb.query().setBookName_PrefixSearch("S2Dao");</b>// ☆Point - '%'は内部で自動的に付与される
        <b>cb.query().setGenreCode_IsNotNull();</b>// ☆Point
        final java.util.List&lt;LdBook&gt; ls = dao.selectList(cb);
        - - - - - - - - -/

        ex) BOOKに対してGENRE_CODEが{'NOVEL', 'HOW-TO-BOOK'}のものを検索
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // select ...
        //   from BOOK book
        //  where book.GENRE_CODE in ('NOVEL', 'HOW-TO-BOOK')
        // 
        final LdBookCB cb = new LdBookCB();
        final java.util.List targetLs = java.util.Arrays.asList(new String[]{"NOVEL", "HOW-TO-BOOK"});
        <b>cb.query().setGenreCode_InScope(targetLs);</b>// ☆Point
        final java.util.List&lt;LdBook&gt; ls = dao.selectList(cb);
        - - - - - - - - -/

        「同じColumnの同じ演算子」に対する条件設定は基本的に上書きです。呼び出した分条件が付くことはありません。
          ex) cb.query().setBookId_Equal(new BigDecimal(1));
              cb.query().setBookId_Equal(new BigDecimal(2));// 2の値で上書き → 1の値の条件は上書きされる
        これは、例えばEqualとかGreaterThanとかの条件を同じColumnの同じ演算子に対して複数指定する意味はないためです。
        NotEqualに関しては複数指定する意味が存在しますが、NotInScopeを利用することに代替できるのでやはり上書き仕様です。
        但し、下記で説明するLikeSearchだけは複数条件設定可能の仕様になっています。それはそのような要件が存在するからです。

        ex) BOOKに対してBOOK_NAMEに'S2Dao100%ガッツ'が含まれている(中間一致)ものを検索
            '100%'の'%'はWildCardとしては扱わず、'|'をEscape文字として'%'をEscapeする。
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // select ...
        //   from BOOK book
        //  where book.BOOK_NAME like '%S2Dao100|%ガッツ%' escape '|'
        // 
        final LdBookCB cb = new LdBookCB();
        <b>final LdLikeSearchOption option = new LdLikeSearchOption().likeContain().escapeByPipeLine();</b>
        <b>cb.query().setBookName_LikeSearch("S2Dao100%ガッツ", option);</b>// ☆Point
        final java.util.List&lt;LdBook&gt; ls = dao.selectList(cb);
        - - - - - - - - -/

        PrefixSearchとLikeSearchの違い：
        PrefixSearchはOption指定無しの単純な前方一致のLike検索です。
        LikeSearchはOption指定必須で前方一致/後方一致/中間一致指定そしてEscape指定が可能なLike検索です。
        LikeSearchでPrefixSearchと同じ条件は実現可能です。ex) new LdLikeSearchOption().likePrefix()
        PrefixSearchの存在意義は薄いかもしれませんが、業務で利用するほとんどはPrefixSearchで
        事足りる場合が多いため、よく使われるMethodとして単純な引数1つの前方一致専用Methodを用意しています。
          ※「単にLikeSearchが後からできただけでしょ」っていう厳しい突っ込みももちろんあります。

        【LikeSearchOptionについて】
        {一致の振舞い}
          likeXxx()を呼び出すことで、一致の振舞い{前方一致/中間一致など}を選択できます。
            likeContain() → 中間一致検索 ※Wildcardは自動付与
            likePrefix()  → 前方一致検索 ※Wildcardは自動付与
            likeSuffix()  → 後方一致検索 ※Wildcardは自動付与
        {Escape処理}
          escapeByXxx()を呼び出すことで、Escape処理(column like 'xxx' escape 'x')を付与できます。
            escapeByPipeLine()  → Escapse文字はPipeLine  '|'
            escapeByAtMark()    → Escapse文字はAtMark    '@'
            escapeBySlash()     → Escapse文字はSlash     '/'
            escapeByBackSlash() → Escapse文字はBackSlash '\'
        {Split処理}
          splitByXxx()を呼び出すことで、引数のvalueをSplitして複数のAND条件として付与できます。
            ex)splitBySpace()
              引数が“aaa bbb”ならば、生成される条件は「column like 'aaa' and column like 'bbb'」
            splitBySpace()                    → 半角空白をDelimiterとしてSplit
            splitBySpaceContainsDoubleByte()  → 全角空白と半角空白をDelimiterとしてSplit
            splitByPipeLine()                 → PipeLine'|'をDelimiterとしてSplit
            ※それぞれ引数'int splitLimitCount'を指定すると、Splitした場合に先頭のsplitLimitCount件だけを有効とする
        {Case処理}
          toUpperCase() → 引数のvalueを大文字に変換して条件を作成
          toLowerCase() → 引数のvalueを大文字に変換して条件を作成
        {SingleByte処理}
          toSingleByteSpace()              → 引数のvalueの全角空白を半角空白に変換
          toSingleByteAlphabetNumber()     → 引数のvalueのAlphabetと数字を半角に変換
          toSingleByteAlphabetNumberMark() → 引数のvalueのAlphabetと数字と記号を半角に変換
        {Local:Japanese処理}
          localJapanese().toDoubleByteKatakana() → 引数のvalueの半角カタカナを全角カタカナに変換
          localJapanese().removeLastLongVowel()  → 引数のvalueの末尾の延ばし文字“ー”を除去
            ex) 引数のvalueが“オーダー”ならば“オーダ”で検索する。


    2. OrderBy句に指定するColumn & {Asc or Desc}のDynamic指定をサポート

        ex) BOOKに対して登録日時の降順で全件検索
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // select ...
        //   from BOOK book
        //  order by book.R_TIME desc
        // 
        final LdBookCB cb = new LdBookCB();
        <b>cb.query().addOrderBy_RTime_Desc();</b>// ☆Point
        final java.util.List&lt;LdBook&gt; ls = dao.selectList(cb);
        - - - - - - - - -/

        ex) BOOKに対してAUTHOR_IDの降順かつBOOK_IDの昇順で全件検索
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // select ...
        //   from BOOK book
        //  order by book.AUTHOR_ID desc, book.BOOK_ID asc
        // 
        final LdBookCB cb = new LdBookCB();
        <b>cb.query().addOrderBy_AuthorId_Desc().addOrderBy_BookId_Asc();</b>// ☆Point
        final java.util.List&lt;LdBook&gt; ls = dao.selectList(cb);
        - - - - - - - - -/


    3. Select句に含める結合先TableのDynamic指定をサポート

        Select句に含めることのできるTableは、MyTableと「2階層まで」のForeignTableです。

        ex) BOOKに対してAUTHORを結合してSelect句に含める検索
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // select book.BOOK_ID, book..., author.AUTHOR_ID as authorId_0, author...
        //   from BOOK book
        //     left outer join AUTHOR author on book.AUTHOR_ID = author.AUTHOR_ID
        //
        final LdBookCB cb = new LdBookCB();
        <b>cb.setupSelect_Author();</b>// ☆Point
        final java.util.List&lt;LdBook&gt; ls = dao.selectList(cb);
        - - - - - - - - -/

        ex) BOOKに対してGENREを結合してさらに親GENREを結合してSelect句に含める検索
            (BOOKから見た場合の“おじいちゃん”を取得したい)
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // select book.BOOK_ID, book...
        //      , genre.GENRE_ID as genreId_2, genre.GENRE_NAME as genreName_2, ...
        //      , genre_n2.GENRE_ID as genreId_2_0, genre_n2.GENRE_NAME as genreName_2_0, ...
        //   from BOOK book
        //     left outer join GENRE genre on book.GENRE_ID = genre.GENRE_ID
        //     left outer join GENRE genre_n2 on genre.PARENT_GENRE_ID = genre_n2.GENRE_ID
        //
        final LdBookCB cb = new LdBookCB();
        <b>cb.setupSelect_Genre().withGenreSelf();</b>// ☆Point
        final java.util.List&lt;LdBook&gt; ls = dao.selectList(cb);
        - - - - - - - - -/


    4. Where句に指定する条件で無限階層のForeignTableのColumnの指定をサポート

        query().queryXxx().queryXxx().queryXxx()...と繋げることで「無限階層」に設定可能

        ex) BOOKに対してForeignTableのAUTHORを結合してAUTHOR_AGEで30歳以上を検索。(AUTHOR_AGE降順)
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // select ...
        //   from BOOK book
        //     left outer join AUTHOR author on book.AUTHOR_ID = author.AUTHOR_ID
        //  where author.AUTHOR_AGE >= 30
        //  order by author.AUTHOR_AGE desc
        //
        final LdBookCB cb = new LdBookCB();
        <b>cb.query().queryAuthor().setAuthorAge_GreaterEqual(30);</b>// ☆Point
        cb.query().queryAuthor().addOrderBy_AuthorAge_Desc();
        final java.util.List&lt;LdBook&gt; ls = dao.selectList(cb);
        - - - - - - - - -/

        AsInlineと付いたMethodの場合は、その条件がInlineViewに設定される。
        “結合する前に結合先Tableを絞り込む”必要がある場合に有効。
          →主に、結合先Tableで論理削除されたRecordは除いて結合したいなど利用する。

        ex) BOOKに対してForeignTableのAUTHORを結合してAUTHORの名称を取得したいが、
            AUTHOR_AGEが0歳のものは無効なものなので、結合に含めたくない検索。(AUTHOR_AGE降順)
            →但し、AUTHOR_AGEが0歳のAUTHORを参照しているBOOKは検索されなければならない。
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // select book.BOOK_ID, book..., author.AUTHOR_ID as authorId_0, author...
        //   from BOOK book
        //     left outer join (select * from AUTHOR where AUTHOR_AGE != 0) author
        //       on book.AUTHOR_ID = author.AUTHOR_ID
        //  order by author.AUTHOR_AGE desc
        //
        final LdBookCB cb = new LdBookCB();
        cb.setupSelect_Author();
        <b>cb.query().queryAuthor().inline().setAuthorAge_NotEqual(new BigDecimal(0));</b>// ☆Point
        cb.query().queryAuthor().addOrderBy_AuthorAge_Desc();
        final java.util.List&lt;LdBook&gt; ls = dao.selectList(cb);
        - - - - - - - - -/

        ※cb.query().queryAuthor().setAuthorAge_NotEqual_AsInline(new BigDecimal(0));というやり方は
          Deprecatedされました。<a href="./deprecated.html">Deprecated</a>をご覧ください。


        ex) 利用者一覧の表示にて、「黒い行動」のレベル４以上を犯したことのある人のみ、「どの位黒いか」のランクを表示
              →LB_USERの検索でBLACK_LISTを結合するが、BLACK_ACTION.BLACK_LEVELが4以上のBLACK_LISTだけを結合
                (BLACK_LIST.BLACK_LIST_IDに対し、InlineのInScopeSubQueryを設定)
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        final LdLbUserCB cb = new LdLbUserCB();
        cb.setupSelect_BlackListAsOne();
        {
            final LdBlackActionCB subCB = new LdBlackActionCB();
            subCB.query().setBlackLevel_GreaterEqual(4);
            cb.query().queryBlackListAsOne().inline()
                      <b>.setBlackListId_InScopeSubQuery_BlackActionList(subCB.query());</b>
        }
        java.util.List&lt;LdLbUser&gt; ls = dao.selectList(cb);
        for (LdLbUser user : ls) {
            // 
            // 以下の条件の利用者の場合は、このMethodの戻り値がnullとなります。
            //   条件：「黒い行動」のレベル４以上を犯したことが無い or そもそもBlackListに登録されていない
            // 
            final String rank = user.getBlackListAsOne().getBlackRank();
        }
        - - - - - - - - -/


    5. fetchFirst(), fetchScope(), fetchPage()によるLimitSearch/PagingSearchをサポート

        ex) BOOKに対して登録日時の降順で、最初の50件のみ検索
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        final LdBookCB cb = new LdBookCB();
        cb.query().addOrderBy_RTime_Desc();
        <b>cb.fetchFirst(50);</b>// ☆Point
        final java.util.List&lt;LdBook&gt; ls = dao.selectList(cb);
        - - - - - - - - -/

        ex) BOOKに対して登録日時の降順で、81件目から100件目のみ検索
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        final LdBookCB cb = new LdBookCB();
        cb.query().addOrderBy_RTime_Desc();
        <b>cb.fetchScope(80, 20);</b>// ☆Point - 80件飛ばして20件分を取得(81件目から100件目)
        final java.util.List&lt;LdBook&gt; ls = dao.selectList(cb);
        - - - - - - - - -/

        ex) BOOKに対して登録日時の降順で、PageSize20件でPaging検索
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        final LdBookCB cb = new LdBookCB();
        cb.query().addOrderBy_RTime_Desc();
        <b>cb.fetchFirst(20);</b>
        <b>cb.fetchPage(1);</b>// ☆Point - 1-20
        final java.util.List&lt;LdBook&gt; lsFirstPage = dao.selectList(cb);

        <b>cb.fetchPage(2);</b>// ☆Point - 21-40
        final java.util.List&lt;LdBook&gt; lsSecondPage = dao.selectList(cb);

        <b>cb.fetchPage(3);</b>// ☆Point - 41-60
        final java.util.List&lt;LdBook&gt; lsThirdPage = dao.selectList(cb);
        - - - - - - - - -/

        [fetchSoope()/fetchPage():補足]
          {Oracle、FirstBird、MySQL、PostgreSQL}など、SQL文法的にLimitSearchが
          サポートされているDBに関しては、そのSQLを利用して検索します(ROWNUMやoffset/limitなど)。

          {SQLServer、DB2}など、SQL文法的に「先頭から何件」という検索しかできないDBに関しては、
          例えば80-100を取得する際に、先頭から100件を取得しResultSetで先頭80件を飛ばして取得します。

            ※Adviceを頂きまして、DB2に関しては、ROW_NUMBER()関数を利用したLimitSearchを
              検討します(2006/09/28現在)。

          それ以外のDBに関しては、ResultSetにおいてOffset/Limit処理を行います。(S2Pagerと同様の方法)
          また、これら処理はDBFluteがDBを判断して自動的に制御します。利用者が意識する必要はありません。


    6. lockForUpdate()による更新Lockのサポート

        ex) BOOKに対してBOOK_ID'3'の完全一致で更新Lockをかけて検索
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        final LdBookCB cb = new LdBookCB();
        cb.query().setBookId_Equal(3);
        <b>cb.lockForUpdate();</b>// ☆Point
        final LdBook entity = dao.selectEntity(cb);
        - - - - - - - - -/

        [lockForUpdate():補足]
          DBによっては結合時のfor updateの振る舞いが変わるため(Lockの範囲/文法Errorなど)、
          利用には注意して下さい(そもそも結合してのfor updateはほとんどの場合不要と思われます)。


    --------------------------------------------
    --- ここからはConditionBeanのAdvance機能 ---
    --------------------------------------------


    7. ExtendedEntityに値受け取り用のPropertyを定義することにより、無限階層のForeignTableのColumnを
       Select句に含めて取得することが可能(BaseTableの導出列として取得。

        ex) BOOKに対して紐づいているGENREの親GENREの親GENREの名称を取得する検索
            (BOOKから見た場合の“ひいおじいちゃん”を取得したい)
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        final LdBookCB cb = new LdBookCB();

        // columnのalias名は'hiioZiichanGenreName'
        <b>cb.query().queryGenre().queryGenreSelf()
                     .queryGenreSelf().includeAsMine_GenreName("hiioZiichanGenreName");</b>

        final java.util.List&lt;LdBook&gt; ls = dao.selectEntity(cb);
        for (final LdBook entity : ls) {
            // BOOKのExtendedEntityに'hiioZiichanGenreName'のget/setを定義しておくこと(これは手動)。
            final String actualOne = <b>entity.getHiioZiichanGenreName();</b>
            ...
        }
        - - - - - - - - -/

        [includeAsMine():補足]
        ※DBFluteがSelect句に含められるのはどうしても「2階層まで」のForeignTableなので、
          どうしても「2階層より」先のTableのColumnの値をSQL一発実行で取得したい場合に有効である。
          また、結合先に“どうしても取ってきたくないColumn”(BLOBとかCLOBとかMemory食うやつ)が
          ある場合に、取得したい列だけを includeAsMine するという方法も可能である。


    8. InScopeSubQuery()によるin検索のサポート ※'where xxx in (select xxx from xxx)'のような検索のこと

        ex) BOOKに対して'中目黒'で始まる図書館に蔵書とされているBOOKをAUTHOR/PUBLISHERを結合して検索
            (OrderByはBOOKのPrimaryKeyの昇順で)
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // [出力されるSQL]
        // select ...
        //   from BOOK
        //     left outer join AUTHOR on ...
        //     left outer join PUBLISHER on ...
        //  where BOOK.BOOK_ID in (select COLLECTION.BOOK_ID
        //                           from COLLECTION
        //                             left outer join LIBRARY on ...
        //                          where LIBRARY.LIBRARY_NAME like '中目黒%')
        //  order by BOOK.BOOK_ID asc
        //
        final LdBookCB cb = new LdBookCB();
        cb.setupSelect_Author();
        cb.setupSelect_Publisher();
        <b>{
            final LdCollectionCB subCB = new LdCollectionCB();
            subCB.query().queryLibrary().setLibraryName_PrefixSearch("中目黒");
            cb.query().setBookId_InScopeSubQuery(subCB.query());
        }</b>
        cb.addOrderBy_PK_Asc();
        final java.util.List&lt;LdBook&gt; ls = dao.selectList(cb);
        - - - - - - - - -/

        [InScopeSubQuery():補足]
          少々複雑なSQLではありますが、ReffererTable(子Table)のColumnで絞り込む検索や
          多重度{n:n}の関係にあるTableのColumnで絞り込む場合の定型的な(一般的な)SQLであることと、
          SQLにおけるin句の副問い合せはとても間違いやすい文法であることを考慮してサポートしました。


    9. 多重度{one-to-one}のReffererTable(子Table)への結合が可能。

        通常はForeignTable(親Table)への結合しかサポートされませんが、多重度が{one-to-oneとDB情報から
        判断できる場合にReffererTableをForeignTableと同じように扱うことが可能です。
        (結合による取得件数の変動が無いためConditionBeanのPolicyに適合する)

        ex) COLLECTIONに対して多重度{1:1}のReffererTableであるCOLLECTION_STATUSの
            STATUS_CODE 'OUT'(貸し出し中) で絞り込み検索
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        final LdCollectionCB cb = new LdCollectionCB();
        cb.setupSelect_CollectionStatusAsOne(); // StatusCodeをSelect句に含めるため

        // 多重度{1:1}のReffererTableには'AsOne'という接尾辞が付く
        <b>cb.query().queryCollectionStatusAsOne().setStatusCode_Equal("OUT");</b>

        final java.util.List&lt;LdCollection&gt; ls = dao.selectList(cb);
        for (final LdCollection entity : ls) {
            // このように取得できる
            final LdCollectionStatus statusEntity = entity.getCollectionStatusAsOne();
            final String statusCode = statusEntity.getCollectionStatusCode();

            // 必ず 'OUT'(貸し出し中) のはず
            assertEqual("OUT", statusCode);
        }
        - - - - - - - - -/

        [多重度{1:1}のReffererTable:補足]
        Project(人)によって方針は様々と思われるますが、DB設計において多重度{1:1}のReffererTableは重要に
        なることがあります。LifeCycleの違い・運用後のDB変更などにおいてよく利用されます。
        多重度{1:1}であるか否かの判定は、ReffererTableのPKもしくはUniqueKeyとReffererTableの自TableへのFKが
        同じ構成の場合にtrueとなります。


    10. PrimaryKeyだけをSelect句に含めて検索することが可能。

        夜間Batchの方式は色々ありますが、
           a. 処理対象RecordのPKを一括でMemory上に取得する。
           b. PKのListをLoopで回す。
             b-1. (Loop内) CurrentのPKで処理対象Recordを一件検索する。
             b-2. (Loop内) 取得した処理対象Recordを処理する(Updateしたり別のTableへInsertしたり)。
           c. Loop終了してBatch終了。
        というような方式を採用する場合に有効。「a」のPKだけの一括検索に適用。
        (PK以外の列を一気に取得すると、処理対象が10万件とかになった場合にMemoryが耐えられない)

        ex) COLLECTIONで、'貸し出し中'になっているRecordをPKだけをSelect句に含めて検索する。
        /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        final LdCollectionCB cb = new LdCollectionCB();
        <b>cb.limitSelect_PKOnly();</b>// ☆Point
        cb.query().queryCollectionStatus().setCollectionStatusCode_Equal_OUT();
        java.util.List&lt;LdCollection&gt; ls = dao.selectList(cb);
        for (LdCollectionCB entity : ls) {
            final BigDecimal collectionId = entity.getCollectionId();
        }
        - - - - - - - - -/

        ちなみにClassificationの設定をしていると、setCollectionStatusCode_Equal_OUT()というように
        タイプセーフにCodeの条件を指定できる。詳しくは<a href="./tips-classification.html">こちら</a>



</pre>
</p>

<!-- document end -->
</html>
