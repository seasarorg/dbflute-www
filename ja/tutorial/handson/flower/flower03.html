<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja" >
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta name="keywords" content="DBFlute,チュートリアル,ハンズオン,hands-on" />
	<link rel="stylesheet" type="text/css" href="../../../../css/sub.css" />
	<!--[if IE 6.0]>
		<link rel="stylesheet" type="text/css" href="../../../../css/cb/sub.css" />
	<![endif]--> 
	<title>模範解答的なセクション 3 | DBFlute</title>
</head>
<body>
<div id="container" class="ct-tutorial">

<div id="mainbar">
<div id="header">
	<div class="navi-upper"><a href="../../../../ja/sitemap.html">SiteMap</a>|<a href="http://d.hatena.ne.jp/jflute/">Author's Blog</a></div>
	<div class="navi-main">
	<ul>
		<li class="hd-introduction"><a href="../../../../ja/introduction/index.html"><img src="../../../../image/parts/navi/link-intro.png" alt="Introduction" width="75" height="32" /></a></li>
		<li class="hd-tutorial"><a href="../../../../ja/tutorial/index.html"><img src="../../../../image/parts/navi/link-tuto.png" alt="Tutorial" width="56" height="24" /></a>
			<ul>
				<li class="hd-architect"><a href="../../../../ja/tutorial/architect.html"><img src="../../../../image/parts/navi/link-arch.png" alt="for Architect" width="80" height="24" /></a></li>
				<li class="hd-developer"><a href="../../../../ja/tutorial/developer.html"><img src="../../../../image/parts/navi/link-dev.png" alt="for Developer" width="87" height="24" /></a></li>
			</ul>
		</li>
		<li class="hd-environment"><a href="../../../../ja/environment/index.html"><img src="../../../../image/parts/navi/link-env.png" alt="Environment" width="84" height="25" /></a>
			<ul>
				<li class="hd-install"><a href="../../../../ja/environment/setup/index.html"><img src="../../../../image/parts/navi/link-setup.png" alt="Setup" width="42" height="24" /></a></li>
				<li class="hd-upgrade"><a href="../../../../ja/environment/upgrade/index.html"><img src="../../../../image/parts/navi/link-upgrade.png" alt="Upgrade" width="61" height="25" /></a></li>
			</ul>
		</li>
		<li class="hd-manual"><a href="../../../../ja/manual/index.html"><img src="../../../../image/parts/navi/link-manual.png" alt="Manual" width="62" height="25" /></a></li>
	</ul>
	</div>
</div>

<div id="content">
	<h1>模範解答的なセクション 3</h1>
	<ul class="indexlist">
		<li><a href="#overview">概要</a></li>
		<li><a href="#stakeholder">このセクションでの登場人物</a></li>
		<li><a href="#flowerimpl">模範解答的な実装</a></li>
	</ul>

	<h2 id="overview">概要</h2>
	<p>
		DBFluteハンズオン、セクション 3 の模範解答的な実装です。
	</p>
	<div class="relatedpage"><a href="../section03.html">ハンズオンセクション 3</a></div>
	<p>
		正解は一つではありませんので、あくまで "的な" というところで、参考までに。
	</p>

	<h2 id="stakeholder">このセクションでの登場人物</h2>
<pre><span class="codetitle">e.g. このセクションでの登場人物 @Directory</span><code>
dbflute-hands-on
 |-src/test/java
 |  |-org.docksidestage.handson
 |  |  |-exercise
 |  |  |  |-<span class="spotlight"><span class="point">HandsOn03Test.java</span></span>
 |  |  |
 |  |  |-unit
 |-src/main/java
 |-<span class="abbreviation">...</span>
</code></pre>

	<h2 id="flowerimpl">模範解答的な実装</h2>
<pre><span class="codetitle">e.g. 模範解答的な実装やってみた @Java</span><code>
<span class="comment">/**
 * @author jflute
 */</span>
<span class="keyword">public class</span> HandsOn03Test <span class="keyword">extends</span> UnitContainerTestCase {

    <span class="comment">// ===================================================================================
    //                                                                           Attribute
    //                                                                           =========</span>
    @Resource
    <span class="keyword">protected</span> MemberBhv <span class="attribute">memberBhv</span>;
    @Resource
    <span class="keyword">protected</span> MemberSecurityBhv <span class="attribute">memberSecurityBhv</span>;
    @Resource
    <span class="keyword">protected</span> PurchaseBhv <span class="attribute">purchaseBhv</span>;

    <span class="comment">// ===================================================================================
    //                                                                     Exercise 1 to 3
    //                                                                     ===============</span>
    <span class="comment">/**
     * [1] 会員名称がSで始まる1968年1月1日以前に生まれた会員を検索
     * o 会員ステータスも取得する
     * o 生年月日の昇順で並べる
     * o 会員が1968/01/01以前であることをアサート
     * o "以前" の解釈は、"その日ぴったりも含む" で。
     * ※もし、よければ HandyDate を使ってみましょう。
     */</span>
    <span class="keyword">public void</span> test_1() <span class="keyword">throws</span> Exception {
        <span class="comment">// ## Arrange ##</span>
        LocalDate targetDate = <span class="keyword">new</span> HandyDate(<span class="literal">"1968/01/01"</span>).getLocalDate(); <span class="comment">// HandyDateの紹介</span>

        <span class="comment">// ## Act ##</span>
        ListResultBean&lt;Member&gt; memberList = <span class="attribute">memberBhv</span>.selectList(<span class="localvar">cb</span> -&gt; {
            <span class="localvar">cb</span>.query().setMemberName_LikeSearch(<span class="literal">"S"</span>, <span class="localvar">op</span> -&gt; <span class="localvar">op</span>.likePrefix());
            <span class="localvar">cb</span>.query().setBirthdate_LessEqual(targetDate);
            <span class="localvar">cb</span>.query().addOrderBy_Birthdate_Asc();
        });

        <span class="comment">// ## Assert ##</span>
        assertHasAnyElement(memberList);
        memberList.forEach(member -&gt; {
            LocalDate birthdate = member.getBirthdate();
            log(member.getMemberName(), birthdate);
            assertTrue(birthdate.isBefore(targetDate) || birthdate.isEqual(targetDate));

            <span class="comment">// << いろいろなやり方がある >></span>
            assertFalse(birthdate.isAfter(targetDate));
            assertTrue(<span class="keyword">new</span> HandyDate(birthdate).isLessEqual(targetDate));
        });
    }

    <span class="comment">/**
     * [2] 会員ステータスと会員セキュリティ情報も取得して会員を検索
     * o 若い順で並べる。生年月日がない人は会員IDの昇順で並ぶようにする
     * o 会員ステータスと会員セキュリティ情報が存在することをアサート
     * ※カージナリティを意識しましょう
     */</span>
    <span class="keyword">public void</span> test_2() <span class="keyword">throws</span> Exception {
        <span class="comment">// ## Arrange ##</span>
        <span class="comment">// ## Act ##</span>
        ListResultBean&lt;Member&gt; memberList = <span class="attribute">memberBhv</span>.selectList(<span class="localvar">cb</span> -&gt; {
            <span class="localvar">cb</span>.setupSelect_MemberStatus();
            <span class="localvar">cb</span>.setupSelect_MemberSecurityAsOne();
        });

        <span class="comment">// ## Assert ##</span>
        <span class="comment">// done jflute [読み物課題] これ最重要 by jflute
        // 会員から会員ステータスは、NotNullのFKカラムで参照しているので、探しにいけば必ず存在する
        // 会員から会員セキュリティは、FKの方向と探しにいく方向が逆なので同じ理論にはなりませんが、
        // ERDのリレーション線に注目。会員退会情報と比べると一目瞭然、黒丸がついていないので必ず存在する1
        //   会員から会員セキュリティ => 1:必ず1 (1:1)
        //   会員から会員退会情報    => 1:いないかもしれない1 (1:0..1)
        // ただ、物理的な制約はありません。業務的というのは、そういうルールにしているいうことだけなんですね。
        // 細かいですが、これがデータベースプログラミングにおいて、とても重要なんですよね。
        // ぜひ、カージナリティに着目してみてください。</span>
        assertHasAnyElement(memberList);
        memberList.forEach(member -&gt; {
            assertTrue(member.getMemberStatus().isPresent());
            assertTrue(member.getMemberSecurityAsOne().isPresent());
        });
    }

    <span class="comment">/**
     * [3] 会員セキュリティ情報のリマインダ質問で2という文字が含まれている会員を検索
     * o 会員セキュリティ情報のデータ自体は要らない
     * o リマインダ質問に2が含まれていることをアサート
     * o アサートするために別途検索処理を入れても誰も文句は言わない
     * ※Actでの検索は本番でも実行されることを想定して、テスト都合でパフォーマンス劣化させないように
     * ※実装できたら、こんどはアサートのための検索の回数が一回になるようにしてみましょう(もし、複数回検索しているのであれば)。
     * また、それもできたら、会員名称とリマインダ質問を会員ごとに一行のログに出力してみましょう。
     */</span>
    <span class="keyword">public void</span> test_3() <span class="keyword">throws</span> Exception {
        <span class="comment">// ## Arrange ##</span>
        String keyword = <span class="literal">"2"</span>;

        <span class="comment">// ## Act ##</span>
        ListResultBean&lt;Member&gt; memberList = <span class="attribute">memberBhv</span>.selectList(<span class="localvar">cb</span> -&gt; {
            <span class="localvar">cb</span>.query().queryMemberSecurityAsOne().setReminderQuestion_LikeSearch(keyword, <span class="localvar">op</span> -&gt; <span class="localvar">op</span>.likeContain());
        });

        <span class="comment">// ## Assert ##</span>
        assertHasAnyElement(memberList);

        <span class="comment">// &lt;&lt; べたべたパターン: ループの中で検索してるのがちょっとよくない &gt;&gt;</span>
        memberList.forEach(member -&gt; {
            <span class="attribute">memberSecurityBhv</span>.selectByPK(member.getMemberId()).alwaysPresent(security -&gt; {
                String question = security.getReminderQuestion();
                log(member.getMemberName(), question);
                assertTrue(question.contains(keyword));
            });
        });

        <span class="comment">// &lt;&lt; SQLを救出パターン &gt;&gt;</span>
        <span class="comment">// IDの抽出、stream()でこう書ける
        //List&lt;Integer&gt; memberIdList = memberList.stream().map(member -&gt; {
        //    return member.getMemberId();
        //}).collect(Collectors.toList());
        // でも、ExtractColumnを使うのが一番</span>
        ListResultBean&lt;MemberSecurity&gt; securityList = <span class="attribute">memberSecurityBhv</span>.selectList(<span class="localvar">cb</span> -&gt; {
            <span class="localvar">cb</span>.query().setMemberId_InScope(<span class="attribute">memberBhv</span>.extractMemberIdList(memberList));
        });
        memberList.forEach(member -&gt; {
            securityList.forEach(security -&gt; {
                <span class="keyword">if</span> (member.getMemberId().equals(security.getMemberId())) {
                    String question = security.getReminderQuestion();
                    log(member.getMemberName(), question);
                    assertTrue(question.contains(keyword));
                    markHere(<span class="literal">"exists"</span>);
                    <span class="comment">// あっ、breakできない!?</span>
                }
            });
            assertMarked(<span class="literal">"exists"</span>);
        });

        <span class="comment">// &lt;&lt; stream()で探してみるパターン &gt;&gt;</span>
        memberList.forEach(member -&gt; {
            securityList.stream().filter(security -> {
                <span class="keyword">return</span> member.getMemberId().equals(security.getMemberId());
            }).findFirst().ifPresent(security -&gt; {
                String question = security.getReminderQuestion();
                log(member.getMemberName(), question);
                assertTrue(question.contains(keyword));
                markHere(<span class="literal">"exists"</span>);
            });
            assertMarked(<span class="literal">"exists"</span>);
        });

        <span class="comment">// &lt;&lt; Mapにしちゃうパターン!? &gt;&gt;</span>
        <span class="comment">// Mapの作り方、collect()が使えるけど、今までのやり方でも Lambda 使えばそれなりにいいかんじ!?
        //Map<Integer, MemberSecurity> securityMap = newHashMap();
        //securityList.forEach(security -&gt; securityMap.put(security.getMemberId(), security));</span>
        Map<Integer, MemberSecurity> securityMap =
                securityList.stream().collect(Collectors.toMap(bean -&gt; bean.getMemberId(), bean -&gt; bean));
        memberList.forEach(member -&gt; {
            MemberSecurity security = securityMap.get(member.getMemberId());
            String question = security.getReminderQuestion();
            log(member.getMemberName(), question);
            assertTrue(question.contains(keyword));
        });
    }

    <span class="comment">// ===================================================================================
    //                                                                     Exercise 4 to 6
    //                                                                     ===============</span>
    <span class="comment">/**
     * [4] 会員ステータスの表示順カラムで会員を並べて検索
     * o 会員ステータスの "表示順" カラムの昇順で並べる
     * o 会員ステータスのデータ自体は要らない
     * o その次には、会員の会員IDの降順で並べる
     * o 会員ステータスのデータが取れていないことをアサート
     * o 会員が会員ステータスごとに固まって並んでいることをアサート
     */</span>
    <span class="keyword">public void</span> test_4() <span class="keyword">throws</span> Exception {
        <span class="comment">// ## Arrange ##</span>
        <span class="comment">// ## Act ##</span>
        ListResultBean&lt;Member&gt; memberList = <span class="attribute">memberBhv</span>.selectList(<span class="localvar">cb</span> -&gt; {
            <span class="localvar">cb</span>.query().queryMemberStatus().addOrderBy_DisplayOrder_Asc();
            <span class="localvar">cb</span>.query().addOrderBy_MemberId_Desc();
        });

        <span class="comment">// ## Assert ##</span>
        assertHasAnyElement(memberList);

        <span class="comment">// << forEach()使ってみたパターン >></span>
        Deque&lt;String&gt; statusDeque = <span class="keyword">new</span> LinkedList&lt;String&gt;();
        Set&lt;String&gt; statusSet = <span class="keyword">new</span> HashSet&lt;String&gt;();
        memberList.forEach(member -&gt; {
            assertFalse(member.getMemberStatus().isPresent());
            String previous = !statusDeque.isEmpty() ? statusDeque.peekLast() : <span class="keyword">null</span>;
            String current = member.getMemberStatusCode();
            log(previous, current);
            <span class="keyword">if</span> (previous != null && !previous.equals(current)) {
                assertFalse(statusSet.contains(current));
            }
            statusDeque.add(current);
            statusSet.add(current);
        });

        <span class="comment">// << 普通のfor文のパターン >></span>
        statusSet.clear(); <span class="comment">// ちと再利用させて</span>
        String previous = <span class="keyword">null</span>;
        <span class="keyword">for</span> (Member member : memberList) {
            assertFalse(member.getMemberStatus().isPresent());
            String current = member.getMemberStatusCode();
            log(previous, current);
            <span class="keyword">if</span> (previous != null && !previous.equals(current)) {
                assertFalse(statusSet.contains(current));
            }
            statusSet.add(current);
            previous = current;
        }

        <span class="comment">// << というか、違うやり方 >></span>
        statusSet.clear(); <span class="comment">// また再利用させて</span>
        previous = null; <span class="comment">// こっちも</span>
        <span class="keyword">int</span> switchCount = <span class="literal">0</span>;
        <span class="keyword">for</span> (Member member : memberList) {
            assertFalse(member.getMemberStatus().isPresent());
            String current = member.getMemberStatusCode();
            log(previous, current);
            <span class="keyword">if</span> (previous != <span class="keyword">null</span> && !previous.equals(current)) {
                ++switchCount;
            }
            statusSet.add(current);
            previous = current;
        }
        assertEquals(statusSet.size() - 1, switchCount);

        <span class="comment">// << これはちょっと強引かな >></span>
        <span class="comment">// reduce()の機能を間借りしてみた...が、reduceしてわけじゃないので紛らわしいかもね</span>
        statusSet.clear(); <span class="comment">// これまた再利用させて</span>
        memberList.stream().reduce((previousMember, currentMember) -> {
            assertFalse(previousMember.getMemberStatus().isPresent());
            assertFalse(currentMember.getMemberStatus().isPresent());
            String currentStatus = currentMember.getMemberStatusCode();
            <span class="keyword">if</span> (!previousMember.getMemberStatusCode().equals(currentStatus)) {
                assertFalse(statusSet.contains(currentStatus));
            }
            statusSet.add(currentStatus);
            return currentMember; <span class="comment">// to be previous at next loop</span>
        });
    }

    <span class="comment">/**
     * [5] 生年月日が存在する会員の購入を検索
     * o 会員名称と会員ステータス名称と商品名も一緒に取得(ログ出力)
     * o 購入日時の降順、購入価格の降順、商品IDの昇順、会員IDの昇順で並べる
     * o OrderBy がたくさん追加されていることをログで確認すること
     * o 購入に紐づく会員の生年月日が存在することをアサート
     * ※ログ出力は、スーパークラスの log() メソッドが利用できる。可変長引数でカンマ区切り出力になる。
     */</span>
    public void test_5() throws Exception {
        <span class="comment">// ## Arrange ##
        // ## Act ##</span>
        ListResultBean&lt;Purchase&gt; purchaseList = <span class="attribute">purchaseBhv</span>.selectList(<span class="localvar">cb</span> -&gt; {
            <span class="localvar">cb</span>.setupSelect_Member().withMemberStatus();
            <span class="localvar">cb</span>.setupSelect_Product();
            <span class="localvar">cb</span>.query().queryMember().setBirthdate_IsNotNull();
            <span class="localvar">cb</span>.query().addOrderBy_PurchaseDatetime_Desc();
            <span class="localvar">cb</span>.query().addOrderBy_PurchasePrice_Desc();
            <span class="localvar">cb</span>.query().addOrderBy_ProductId_Asc();
            <span class="localvar">cb</span>.query().addOrderBy_MemberId_Asc();
        });

        <span class="comment">// ## Assert ##</span>
        assertHasAnyElement(purchaseList);
        purchaseList.forEach(purchase -&gt; {
            Member member = purchase.getMember().get();
            MemberStatus status = member.getMemberStatus().get();
            Product product = purchase.getProduct().get();
            log(purchase.getProductId(), member.getMemberName(), status.getMemberStatusName(), product.getProductName(),
                    member.getMemberId());
        });
    }

    <span class="comment">/**
     * [6] 会員名称に "vi" を含む会員を検索
     * o 会員ステータスも一緒に取得
     * o ただし、会員ステータス名称だけ取得できればいい (説明や表示順カラムは不要)
     * o 2005年10月の1日から3日までに正式会員になった会員を検索
     * o 会員名称と正式会員日時と会員ステータス名称をログに出力
     * o 会員ステータスがコードと名称だけが取得されていることをアサート
     * o 会員の正式会員日時が指定された条件の範囲内であることをアサート
     * ※Java8 (DBFlute-1.1) なら、assertException(...)を使うとよいでしょう
     * ※実装できたら、こんどはスーパークラスのメソッド adjustMember_FormalizedDatetime_...() を使って、10月1日ジャスト(時分秒なし)の正式会員日時を持つ会員データを作成してテスト実行してみましょう。 もともと一件しかなかった検索結果が「二件」になるはずです。
     * @throws Exception
     */</span>
    public void test_6() throws Exception {
        <span class="comment">// ## Arrange ##</span>
        LocalDateTime fromDate = <span class="keyword">new</span> HandyDate("2005/10/01").getLocalDateTime();
        LocalDateTime toDate = <span class="keyword">new</span> HandyDate("2005/10/03").getLocalDateTime();
        String nameKeyword = <span class="literal">"vi"</span>;
        adjustMember_FormalizedDatetime_FirstOnly(fromDate, nameKeyword);

        <span class="comment">// ## Act ##</span>
        ListResultBean&lt;Member&gt; memberList = <span class="attribute">memberBhv</span>.selectList(cb -&gt; {
            <span class="localvar">cb</span>.setupSelect_MemberStatus();
            <span class="localvar">cb</span>.specify().specifyMemberStatus().columnMemberStatusName();
            <span class="localvar">cb</span>.query().setMemberName_LikeSearch(nameKeyword, <span class="localvar">op</span> -&gt; <span class="localvar">op</span>.likeContain());
            <span class="localvar">cb</span>.query().setFormalizedDatetime_FromTo(fromDate, toDate, <span class="localvar">op</span> -&gt; <span class="localvar">op</span>.compareAsDate());
        });

        <span class="comment">// ## Assert ##</span>
        assertHasAnyElement(memberList);
        LocalDateTime addedToDate = toDate.plusDays(1);
        <span class="keyword">for</span> (Member member : memberList) {
            LocalDateTime formalizedDatetime = member.getFormalizedDatetime();
            MemberStatus status = member.getMemberStatus().get();
            String statusName = status.getMemberStatusName();
            log(member.getMemberName(), formalizedDatetime, statusName);

            assertNotNull(status.getMemberStatusCode());
            assertNotNull(statusName);
            assertException(NonSpecifiedColumnAccessException.class, () -&gt; status.getDisplayOrder());
            assertException(NonSpecifiedColumnAccessException.class, () -&gt; status.getDescription());

            assertTrue(fromDate.isEqual(formalizedDatetime) || fromDate.isBefore(formalizedDatetime));
            assertTrue(addedToDate.isAfter(formalizedDatetime));
        }
    }

    <span class="comment">/**
     * [7] 正式会員になってから一週間以内の購入を検索
     * o 会員と会員ステータス、会員セキュリティ情報も一緒に取得
     * o 商品と商品ステータス、商品カテゴリ、さらに上位の商品カテゴリも一緒に取得
     * o 上位の商品カテゴリ名が取得できていることをアサート
     * o 購入日時が正式会員になってから一週間以内であることをアサート
     * ※ログ出力と書いてなくても、テストの動作を確認するためにも(自由に)ログ出力すると良い。
     * ※実装できたら、こんどはスーパークラスのメソッド adjustPurchase_PurchaseDatetime_...() を呼び出し、調整されたデータによって検索結果が一件増えるかどうか確認してみましょう。 もし増えないなら、なぜ増えないのか...
     * @throws Exception
     */</span>
    public void test_7() throws Exception {
        <span class="comment">// ## Arrange ##</span>
        adjustPurchase_PurchaseDatetime_fromFormalizedDatetimeInWeek();

        <span class="comment">// ## Act ##</span>
        ListResultBean<Purchase> purchaseList = <span class="attribute">purchaseBhv</span>.selectList(<span class="localvar">cb</span> -&gt; {
            <span class="localvar">cb</span>.setupSelect_Member().withMemberStatus();
            <span class="localvar">cb</span>.setupSelect_Member().withMemberSecurityAsOne();
            <span class="localvar">cb</span>.setupSelect_Product().withProductStatus();
            <span class="localvar">cb</span>.setupSelect_Product().withProductCategory().withProductCategorySelf();
            <span class="localvar">cb</span>.columnQuery(<span class="localvar">colCB</span> -&gt; {
                <span class="localvar">colCB</span>.specify().columnPurchaseDatetime();
            }).greaterEqual(<span class="localvar">colCB</span> -&gt; { <span class="comment">// ぴったしは含むとする</span>
                <span class="localvar">colCB</span>.specify().specifyMember().columnFormalizedDatetime();
            });
            <span class="localvar">cb</span>.columnQuery(<span class="localvar">colCB</span> -&gt; {
                <span class="localvar">colCB</span>.specify().columnPurchaseDatetime();
            }).lessThan(<span class="localvar">colCB</span> -&gt; {
                <span class="localvar">colCB</span>.specify().specifyMember().columnFormalizedDatetime();
            }).convert(<span class="localvar">op</span> -&gt; <span class="localvar">op</span>.truncTime().addDay(<span class="literal">8</span>)); <span class="comment">// 24*7 hours + あるふぁ</span>
        });

        <span class="comment">// ## Assert ##</span>
        assertHasAnyElement(purchaseList);
        <span class="keyword">for</span> (Purchase purchase : purchaseList) {
            Product product = purchase.getProduct().get();
            product.getProductCategory().get().getProductCategorySelf().alwaysPresent(parent -&gt; { <span class="comment">// categoryなけりゃ落ちる</span>
                assertNotNull(parent.getProductCategoryName()); <span class="comment">// not null だから、ここまでくりゃあるはずだけど念のため</span>
            });
            LocalDateTime purchaseDatetime = purchase.getPurchaseDatetime();
            LocalDateTime formalizedDatetime = purchase.getMember().get().getFormalizedDatetime();
            LocalDateTime oneWeekAfter = <span class="keyword">new</span> HandyDate(formalizedDatetime).moveToDayJust().addDay(<span class="literal">8</span>).getLocalDateTime();
            log(<span class="literal">"purchaseDatetime={}, formalizedDatetime={}, {}"</span>, purchaseDatetime, formalizedDatetime, product.getProductName());
            assertTrue(purchaseDatetime.isEqual(formalizedDatetime) || purchaseDatetime.isAfter(formalizedDatetime));
            assertTrue(purchaseDatetime.isBefore(oneWeekAfter));
        }
    }

    <span class="comment">/**
     * [8] 1974年までに生まれた、もしくは不明の会員を検索
     * o 会員ステータス名称、リマインダ質問と回答、退会理由入力テキストも取得(ログ出力)
     * o 若い順だが生年月日が null のデータを最初に並べる
     * o 生年月日が指定された条件に合致することをアサート
     * o 1974年生まれの人が含まれていることをアサート
     * o 生まれが不明の会員が先頭になっていることをアサート
     * @throws Exception
     */</span>
    public void test_8() throws Exception {
        <span class="comment">// ## Arrange ##</span>
        <span class="keyword">int</span> <span class="localvar">inputYear</span> = <span class="literal">1974</span>; <span class="comment">// 画面から検索条件として飛んできたと想定</span>
        LocalDate <span class="localvar">targetDate</span> = LocalDate.of(inputYear, <span class="literal">1</span>, <span class="literal">1</span>);

        <span class="comment">// ## Act ##</span>
        ListResultBean&lt;Member&gt; <span class="localvar">memberList</span> = <span class="attribute">memberBhv</span>.selectList(cb -&gt; {
            <span class="localvar">cb</span>.setupSelect_MemberStatus();
            <span class="localvar">cb</span>.setupSelect_MemberSecurityAsOne();
            <span class="localvar">cb</span>.setupSelect_MemberWithdrawalAsOne();
            <span class="localvar">cb</span>.query().setBirthdate_FromTo(null, targetDate, <span class="localvar">op</span> -&gt; <span class="localvar">op</span>.compareAsYear().allowOneSide().orIsNull());
            <span class="comment">// おもいで</span>
            <span class="comment">//<span class="localvar">cb</span>.orScopeQuery(orCB -&gt; {
            //    orCB.query().setBirthdate_FromTo(null, targetDate, op -&gt; op.compareAsYear().allowOneSide());
            //    orCB.query().setBirthdate_IsNull();
            //});</span>
            <span class="localvar">cb</span>.query().addOrderBy_Birthdate_Desc().withNullsFirst();
        });

        <span class="comment">// ## Assert ##</span>
        assertHasAnyElement(<span class="localvar">memberList</span>);
        LocalDate <span class="localvar">nextYear</span> = targetDate.plusYears(<span class="literal">1</span>);
        <span class="keyword">boolean</span> <span class="localvar">existsTarget</span> = <span class="keyword">false</span>;
        <span class="keyword">for</span> (Member <span class="localvar">member</span> : <span class="localvar">memberList</span>) {
            MemberStatus <span class="localvar">status</span> = member.getMemberStatus().get();
            MemberSecurity <span class="localvar">security</span> = <span class="localvar">member</span>.getMemberSecurityAsOne().get();
            String <span class="localvar">reason</span> = <span class="localvar">member</span>.getMemberWithdrawalAsOne().map(<span class="localvar">wdl</span> -&gt; <span class="localvar">wdl</span>.getWithdrawalReasonInputText()).orElse(<span class="keyword">null</span>);
            log(<span class="localvar">status</span>.getMemberStatusName(), <span class="localvar">security</span>.getReminderQuestion(), <span class="localvar">security</span>.getReminderAnswer(), <span class="localvar">reason</span>);

            LocalDate <span class="localvar">birthdate</span> = <span class="localvar">member</span>.getBirthdate();
            <span class="keyword">if</span> (<span class="localvar">birthdate</span> != <span class="keyword">null</span>) {
                assertTrue(<span class="localvar">birthdate</span>.isBefore(<span class="localvar">nextYear</span>));
                <span class="keyword">if</span> (<span class="localvar">birthdate</span>.getYear() == <span class="localvar">targetDate</span>.getYear()) {
                    <span class="localvar">existsTarget</span> = <span class="keyword">true</span>;
                }
            }
        }
        assertTrue(<span class="localvar">existsTarget</span>);
        assertNull(<span class="localvar">memberList</span>.get(<span class="literal">0</span>).getBirthdate()); <span class="comment">// 先頭なのでこれでOK</span>
    }

    <span class="comment">/**
     * [9] 無効な条件は無視されることを確認しつつ生年月日のない会員を検索
     * o 会員名称の等値条件に null を設定
     * o 会員アカウントの等値条件に空文字を設定
     * o 生年月日がない、という条件を設定
     * o 2005年6月に正式会員になった会員は先にして、会員IDの降順で並べる
     * o 会員名称や会員アカウントの条件がないことをログで確認すること
     * o 検索された会員の生年月日が存在しないことをアサート
     * o 2005年6月に正式会員になった会員が先に並んでいることをアサート
     * ※Java8 (DBFlute-1.1) なら、<span class="localvar">cb</span>.ignoreNullOrEmptyQuery()を使うとよいでしょう
     * @throws Exception
     */</span>
    <span class="keyword">public void</span> test_9() <span class="keyword">throws</span> Exception {
        <span class="comment">// ## Arrange ##</span>
        <span class="keyword">int</span> <span class="localvar">inputYear</span> = <span class="literal">2005</span>; <span class="comment">// 画面から検索条件として飛んできたと想定</span>
        <span class="keyword">int</span> <span class="localvar">inputMonth</span> = <span class="literal">6</span>; <span class="comment">// 上に同じ</span>
        LocalDate <span class="localvar">fromDate</span> = LocalDate.of(<span class="localvar">inputYear</span>, <span class="localvar">inputMonth</span>, <span class="literal">1</span>);

        <span class="comment">// ## Act ##</span>
        ListResultBean&lt;Member&gt; <span class="localvar">memberList</span> = memberBhv.selectList(<span class="localvar">cb</span> -&gt; {
            <span class="localvar">cb</span>.ignoreNullOrEmptyQuery();
            <span class="localvar">cb</span>.query().setMemberName_Equal(<span class="keyword">null</span>);
            <span class="localvar">cb</span>.query().setMemberAccount_Equal(<span class="literal">""</span>);
            <span class="localvar">cb</span>.query().setBirthdate_IsNull();
            <span class="localvar">cb</span>.query().addOrderBy_FormalizedDatetime_Asc().withManualOrder(<span class="localvar">op</span> -&gt; {
                <span class="localvar">op</span>.when_FromTo(<span class="localvar">fromDate</span>, <span class="localvar">fromDate</span>, <span class="localvar">ftOp</span> -&gt; <span class="localvar">ftOp</span>.compareAsMonth());
            });
            <span class="localvar">cb</span>.query().addOrderBy_MemberId_Desc();
        });

        <span class="comment">// ## Assert ##</span>
        assertHasAnyElement(<span class="localvar">memberList</span>);
        <span class="keyword">boolean</span> <span class="localvar">existsTargetMonth</span> = <span class="keyword">false</span>;
        <span class="keyword">boolean</span> <span class="localvar">passedBorder</span> = <span class="keyword">false</span>;
        HandyDate <span class="localvar">fromHandy</span> = <span class="keyword">new</span> HandyDate(fromDate);
        <span class="keyword">for</span> (Member <span class="localvar">member</span> : memberList) {
            assertNull(<span class="localvar">member</span>.getBirthdate());
            LocalDateTime <span class="localvar">formalizedDatetime</span> = <span class="localvar">member</span>.getFormalizedDatetime();
            <span class="keyword">if</span> (<span class="localvar">formalizedDatetime</span> != <span class="keyword">null</span> && <span class="localvar">fromHandy</span>.isMonthOfYearSameAs(<span class="localvar">formalizedDatetime</span>)) {
                assertFalse(<span class="localvar">passedBorder</span>);
                <span class="localvar">existsTargetMonth</span> = <span class="keyword">true</span>;
            } <span class="keyword">else</span> { <span class="comment">// null or others</span>
                <span class="localvar">passedBorder</span> = <span class="keyword">true</span>;
            }
        }
        assertTrue(<span class="localvar">existsTargetMonth</span>);
        assertTrue(<span class="localvar">passedBorder</span>);
    }

    <span class="comment">// ===================================================================================
    //                                                                              Paging
    //                                                                              ======</span>
    <span class="comment">/**
     * 全ての会員をページング検索
     * o 会員ステータス名称も取得
     * o 会員IDの昇順で並べる
     * o ページサイズは 3、ページ番号は 1 で検索すること
     * o 会員ID、会員名称、会員ステータス名称をログに出力
     * o SQLのログでカウント検索時と実データ検索時の違いを確認
     * o 総レコード件数が会員テーブルの全件であることをアサート
     * o 総ページ数が期待通りのページ数(計算で導出)であることをアサート
     * o 検索結果のページサイズ、ページ番号が指定されたものであることをアサート
     * o 検索結果が指定されたページサイズ分のデータだけであることをアサート
     * o PageRangeを 3 にして PageNumberList を取得し、[1, 2, 3, 4]であることをアサート
     * o 前のページが存在しないことをアサート
     * o 次のページが存在することをアサート
     * @throws Exception
     */</span>
    <span class="keyword">public void</span> test_paging() <span class="keyword">throws</span> Exception {
        <span class="comment">// ## Arrange ##</span>
        <span class="keyword">int</span> pageSize = <span class="literal">3</span>;
        <span class="keyword">int</span> pageNumber = <span class="literal">1</span>;

        <span class="comment">// ## Act ##</span>
        <span class="comment">// [SQL]
        // MySQL's found_rows() is used here
        //  data  : select sql_calc_found_rows ... limit 0, 3
        //  count : select found_rows()</span>
        PagingResultBean<Member> page = memberBhv.selectPage(<span class="localvar">cb</span> -> {
            <span class="localvar">cb</span>.setupSelect_MemberStatus();
            <span class="localvar">cb</span>.query().addOrderBy_MemberId_Asc();
            <span class="localvar">cb</span>.paging(pageSize, pageNumber);
        });

        <span class="comment">// ## Assert ##</span>
        assertHasAnyElement(page);
        page.forEach(member -> {
            log(member.getMemberId(), member.getMemberName(), member.getMemberStatus().get().getMemberStatusName());
        });
        <span class="keyword">int</span> allRecordCount = page.getAllRecordCount();
        assertEquals(memberBhv.selectCount(<span class="localvar">cb</span> -> {}), allRecordCount);
        assertEquals((allRecordCount / pageSize) + (allRecordCount % pageSize > <span class="literal">0</span> ? <span class="literal">1</span> : <span class="literal">0</span>), page.getAllPageCount());
        assertEquals(pageSize, page.getPageSize());
        assertEquals(pageNumber, page.getCurrentPageNumber());
        assertEquals(pageSize, page.size());
        assertEquals(Arrays.asList(<span class="literal">1</span>, <span class="literal">2</span>, <span class="literal">3</span>, <span class="literal">4</span>), page.pageRange(op -> op.rangeSize(<span class="literal">3</span>)).createPageNumberList());
        assertFalse(page.existsPreviousPage());
        assertTrue(page.existsNextPage());
    }

    <span class="comment">// ===================================================================================
    //                                                                              Cursor
    //                                                                              ======</span>
    <span class="comment">/**
     * 会員ステータスの表示順カラムで会員を並べてカーソル検索
     * o 会員ステータスの "表示順" カラムの昇順で並べる
     * o 会員ステータスのデータも取得
     * o その次には、会員の会員IDの降順で並べる
     * o 会員ステータスが取れていることをアサート
     * o 会員が会員ステータスごとに固まって並んでいることをアサート
     * o 検索したデータをまるごとメモリ上に持ってはいけない
     * o (要は、検索結果レコード件数と同サイズのリストや配列の作成はダメ)
     * @throws Exception
     */</span>
    <span class="keyword">public void</span> test_cursor() <span class="keyword">throws</span> Exception {
        <span class="comment">// ## Arrange ##</span>
        Deque&lt;String&gt; statusDeque = new LinkedList&lt;String&gt;();
        Set&lt;String&gt; statusSet = new HashSet&lt;String&gt;();

        <span class="comment">// ## Act ##</span>
        memberBhv.selectCursor(<span class="localvar">cb</span> -> {
            <span class="localvar">cb</span>.setupSelect_MemberStatus();
            <span class="localvar">cb</span>.query().queryMemberStatus().addOrderBy_DisplayOrder_Asc();
            <span class="localvar">cb</span>.query().addOrderBy_MemberId_Desc();
        } , member -> {
            <span class="comment">// ## Assert ##</span>
            assertTrue(member.getMemberStatus().isPresent());
            String previous = !statusDeque.isEmpty() ? statusDeque.peekLast() : <span class="keyword">null</span>;
            String current = member.getMemberStatusCode();
            log(previous, current);
            <span class="keyword">if</span> (previous != <span class="keyword">null</span> && !previous.equals(current)) {
                assertFalse(statusSet.contains(current));
            }
            statusDeque.clear(); <span class="comment">// so always previous only</span>
            statusDeque.add(current);
            statusSet.add(current);
        });
        assertHasAnyElement(statusSet);
    }

    <span class="comment">// ===================================================================================
    //                                                                           InnerJoin
    //                                                                           =========</span>
    <span class="comment">/**
     * いままで書いたエクササイズでもいいですし、新たに適当なテストメソッドを作ってもいいので、
     * ログのSQLを目視で確認して InnerJoinAutoDetect を実感してみるとよいでしょう。
     * @throws Exception
     */</span>
    <span class="keyword">public void</span> test_confirm_InnerJoinAutoDetect() <span class="keyword">throws</span> Exception {
        <span class="comment">// select ...
        //  from member dfloc
        //    inner join member_status dfrel_0 on dfloc.MEMBER_STATUS_CODE = dfrel_0.MEMBER_STATUS_CODE
        //    left outer join member_security dfrel_1 on dfloc.MEMBER_ID = dfrel_1.MEMBER_ID
        //    inner join member_withdrawal dfrel_3 on dfloc.MEMBER_ID = dfrel_3.MEMBER_ID
        // where dfrel_3.WITHDRAWAL_DATETIME >= '2015-10-15 14:49:56.608'</span>
        memberBhv.selectList(cb -> {
            cb.setupSelect_MemberStatus();
            cb.setupSelect_MemberSecurityAsOne();
            cb.setupSelect_MemberWithdrawalAsOne();
            cb.query().queryMemberWithdrawalAsOne().setWithdrawalDatetime_GreaterEqual(currentLocalDateTime());
        });
    }
}
</code></pre>

</div>
</div>

<div id="sidebar">
	<div class="logo"><a href="../../../../"><img src="../../../../image/parts/logo.png" alt="dbflute-logo" width="240" height="110" /></a></div>
<ul>
		<li><a href="../../../../ja/tutorial/architect.html">アーキテクトのチュートリアル</a>
			<ul>
				<li><a href="../../../../ja/tutorial/architect.html#knowledge">必要な知識</a></li>
				<li><a href="../../../../ja/tutorial/architect.html#action">開発時にやるべきこと</a></li>
			</ul>
		</li>
		<li><a href="../../../../ja/tutorial/developer.html">ディベロッパーのチュートリアル</a>
			<ul>
				<li><a href="../../../../ja/tutorial/developer.html#about">DBFluteとは？</a></li>
				<li><a href="../../../../ja/tutorial/developer.html#style">実装スタイル</a></li>
				<li><a href="../../../../ja/tutorial/developer.html#policy">ディベロッパーの十か条</a></li>
				<li class="upper-space"><a href="../../../../ja/tutorial/developer.html#faq">ディベロッパーのFAQ</a></li>
				<li><a href="../../../../ja/tutorial/developer.html#supplement">補足資料</a></li>
			</ul>
		</li>
		<li><a href="../../../../ja/tutorial/handson/index.html">DBFluteハンズオン</a>
			<ul>
				<li><a href="../../../../ja/tutorial/handson/section01.html">Section 1</a></li>
				<li><a href="../../../../ja/tutorial/handson/section02.html">Section 2</a></li>
				<li><a href="../../../../ja/tutorial/handson/section03.html">Section 3</a></li>
				<li class="upper-space"><a href="../../../../ja/tutorial/handson/section04.html">Section 4</a></li>
				<li><a href="../../../../ja/tutorial/handson/section05.html">Section 5</a></li>
				<li class="upper-space"><a href="../../../../ja/tutorial/handson/section06.html">Section 6</a></li>
				<li><a href="../../../../ja/tutorial/handson/section07.html">Section 7</a></li>
				<li><a href="../../../../ja/tutorial/handson/section08.html">Section 8</a></li>
				<li class="upper-space"><a href="../../../../ja/tutorial/handson/section09.html">Section 9</a></li>
				<li><a href="../../../../ja/tutorial/handson/section10.html">Section 10</a></li>
				<li><a href="../../../../ja/tutorial/handson/section11.html">Section 11</a></li>
			</ul>
		</li>
	</ul>

</div>

<div id="footer">
	<div><a href="../../../../ja/sitemap.html">SiteMap</a> <a href="http://d.hatena.ne.jp/jflute">Author's Blog</a><a href="https://www.seasar.org/issues/browse/DBFLUTE">BTS</a></div>
	<ul class="footer-navi">
		<li class="hd-introduction"><a href="../../../../ja/introduction/index.html">Introduction</a></li>
		<li class="hd-tutorial"><a href="../../../../ja/tutorial/index.html">Tutorial</a>
			<ul>
				<li class="hd-architect"><a href="../../../../ja/tutorial/architect.html">for Architect</a></li>
				<li class="hd-developer"><a href="../../../../ja/tutorial/developer.html">for Developer</a></li>
			</ul>
		</li>
		<li class="hd-environment"><a href="../../../../ja/environment/index.html">Environment</a>
			<ul>
				<li class="hd-install"><a href="../../../../ja/environment/setup/index.html">Setup</a></li>
				<li class="hd-upgrade"><a href="../../../../ja/environment/upgrade/index.html">Upgrade</a></li>
			</ul>
		</li>
		<li class="hd-manual"><a href="../../../../ja/manual/index.html">Manual</a></li>
	</ul>

</div>

</div>
</body>
</html>
