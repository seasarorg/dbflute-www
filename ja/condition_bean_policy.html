<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- don't edit start -->
<head>
<title>Seasar - DI Container with AOP - </title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<link href="seasar_b.css" type="text/css" rel="stylesheet" media="screen" />
<link href="seasar_p.css" type="text/css" rel="stylesheet" media="print" />
<script src="seasar_b.js" type="text/JavaScript" language="JavaScript"></script>
</head>
<body onload="preload('ja')">
<table width="100%" border="0" cellspacing="0" cellpadding="0" align="left"><tr>
<td align="left" valign="top" width="780"><table width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr><td colspan="7"><img height="5" width="780" src="images/top01_b.gif" alt=""></td></tr>
<tr><td><img height="117" width="235" src="images/top02_b.gif" alt="Seasar"></td>
<td colspan="3"><img height="117" width="289" src="images/top03.gif" alt="DI Container with AOP"></td>
<td colspan="3"><img height="117" width="256" src="images/spacer.gif" alt=""></td>
</tr><tr><td rowspan="2"><img src="images/top04.gif" alt="" height="49" width="235"></td>
<td><a href="http://www.seasar.org/index.html"><img src="images/menu01_b_ja.gif" height="30" width="78" border="0" alt="" id="menu01" onmouseover="swap(1)" onmouseout="restore(1)"></a></td>
<td><a href="http://www.seasar.org/projects.html"><img src="images/menu02_b_ja.gif" height="30" width="101" border="0" alt="" id="menu02" onmouseover="swap(2)" onmouseout="restore(2)"></a></td>
<td><a href="http://www.seasar.org/products.html"><img src="images/menu03_b_ja.gif" height="30" width="110" border="0" alt="" id="menu03" onmouseover="swap(3)" onmouseout="restore(3)"></a></td>
<td><a href="http://www.seasar.org/resources.html"><img src="images/menu04_b_ja.gif" height="30" width="113" border="0" alt="" id="menu04" onmouseover="swap(4)" onmouseout="restore(4)"></a></td>
<td><img src="images/menu05_b_ja.gif" height="30" width="109" border="0" alt="" id="menu05" onmouseover="swap(5)" onmouseout="restore(5)"></td>
<td><img height="30" width="34" src="images/menu06.gif" alt=""></td></tr><tr>
<td colspan="6"><img height="19" width="545" src="images/spacer.gif" alt=""></td></tr></table>
<table  width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr align="left" valign="top"><td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td><td width="740" class="main">
<!-- don't edit end -->
<!-- document start -->
<p>
<a href="index.html">to Top</a>
<p><b>
ConditionBeanのPolicyを記述します。
<p></b>
<pre>

    ConditionBeanのPolicy：

    _/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

                                              ＜可読性＞

    このようなSQL自動生成Objectは、他のO/R-Mapperで既にもっとRichなものが存在します。(俗に言うCriteria)
    確かに便利ですが、複雑なQueryを頑張って作成すると
      ☆｛パッと見「どんなSQLなのか?」がわかりにくいもの｝☆
    になります。これは大問題と考えています。

    DBFluteは、その辺の問題を踏まえた上でConditionBeanを提供し、S2Daoの“外だしSQL”と連携します。
      **************************
      - 簡単なSQLはConditionBean
      - 複雑なSQLは“外だしSQL”
      **************************
    そのためには、その境目が明確にしていることが重要だと思っています(開発者を迷わせないために)。

    ConditionBeanは、｛Or句 / GroupBy句 / Union構文｝をサポートしません。
    それはできないのではなくあえてサポートしていません。
    これらの構文をサポートした場合、それこそ先述した｛パッと見「どんなSQLなのか?」がわかりにくいもの｝
    になってしまう可能性があります。複雑なSQLにSQL自動生成Objectを使うと逆に開発効率を落とすことになり、
    本末転倒となってしまうのです。
    そのようなSQLに関しては、それこそS2Daoの“外だしSQL”の出番だと考えています。

      ※「Or句ぐらいはサポートしても...」と思われる方もいるかもしれませんが、Or句は一般に
        パフォーマンス劣化を招きやすい演算子であり、パフォーマンスチューニング時にUnionに
        置き換えるケースもよくあるため、これは外だしSQLの領域としてConditionBeanでは
        サポートするべきでないと判断しました。

    ConditionBeanは、Tableの結合において｛inner join｝をサポートしません。
    結合は全て left outer join で実現されます。
    この方針の理由も
      ☆｛パッと見「どんなSQLなのか?」がわかりにくいもの｝☆
    を止めたいからです。
    「結合するだけで中心Tableの取得件数が絞り込まれることはない」ということを保証したいのです。


      - - - - - - - - - - - - - - - - - - - - - -
      やれることが限られている → 可読性がUPする
      - - - - - - - - - - - - - - - - - - - - - -
      ※このように作者は考えています。



                                          ＜方針のシンプル性＞

    現場では「SeasarもS2Daoも知らない開発者が突然今日から実装チームに参加する」ということがよくあります。
    しかも、それが毎週毎週1人2人ずつ投入されることが多々あります。(Managementへの不満はさておいて)
    そのため、開発者にあまり多くの方法を覚えてもらうことは、それはコストにつながります。

      - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      “ConditionBean”と“外だしSQL”のこの２点のみで全てのDBアクセスを実現します。
      - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    S2Daoが提供する｛SQL自動生成機能 / QUERY-Annotation / S2Pager｝は
    もちろん利用は可能ですが、DBFluteのPolicyではこれらを利用する必要はありません。
    ConditionBeanで完全に代替されます。

      {S2Daoが提供が提供するSQL自動生成機能 & QUERY-Annotation}
      S2DaoのSQL自動生成機能は、RELKEY-Annotationで指定されたTable全てを結合します。
      これを現実の業務で利用するのは厳しいです。

      {S2Pager}
      S2PagerはLimitOffset構文をサポートしているDB以外では、「ResultSetによるデータの読み飛ばし」
      を利用します。これは便利ですが、多少なりパフォーマンスに影響します。
      ConditionBeanでは、MySQLやPostgreSQLのLimitOffset構文だけでなく、
        ｛OracleのROWNUM / FirebirdのFirst構文 / SQLServerのTop / DB2のFetchFirst構文｝
      をフル活用してPagingを実現します。
        ※これら構文が利用できないDB、もしくは、SQLServerやDB2のOffset部処理に関しては、
          S2Pagerと同様に「ResultSetによるデータの読み飛ばし」を利用します。



                                          ＜パフォーマンス考慮＞

    昔々、DBFluteの前身であるS2DaoGenが出来たばかりの頃、
    ConditionBeanはもっと貧弱で、かつ、検索が遅いものでした。(2005年8月頃!?)

    なぜ遅かったかを説明します。

      - Seasar初期化時に、全てのWhere句の条件を予め作成する。
      - SQL実行時に、IFコメント解析にて値がNULLでないWhere句条件だけ残して他は全て消す。

    これはS2DaoのSQL自動生成機能における既定の動きです。
    そして、これに対し以下を追加しました。

      - 演算子を{Equal, NotEqual, GreaterEqual...}などをサポート
      - FK先TableのColumnも含めてDTOを自動生成

    これで汎用的な検索が実現できたのですが、実は内部処理で問題がありました。
    それは、Columnの数が多いTable、もしくはFKの多いTableにて顕著に発生しました。

      A. Seasar初期化時に、自動生成されるSQLが膨大で読み込みが遅い。(かつMemoryも食う)
      B. SQL実行時に、IFコメントの数が膨大で判定処理が遅い。
      C. FK先を全て結合してSelect句に含めてしまうので遅い。(かつMemoryも食う)
      D. Compile時に、DTOが膨大で遅い。(場合によってはEclipseの限界を超えCompile不能となる)

    しかもこの現象は、「Columnが1つ追加」されると「倍」ではなく「累乗」の勢いで顕著になります。
    現実使い物にはなりませんでした。

    DB設計がそもそも問題があるという話もありますが、DBを修正する権利のないプロジェクトは多々あります。
    また、細かく正規化してTableを分けると逆にS2Daoの「1階層まで」しか結合できない制限に泣かされます。
    そして、いくら列が少ないと言っても、「遅い」ことには変わりがないのです。


    S2Dao-1.0.29である機能が実装されたことをきっかけに、この方法を完全に捨てました。(2005年12月頃!?)
    ConditionBeanはS2Daoの機能を借りるのではなく、自動生成されるConditionBean-Frameworkを利用します。
    <b>
      a. Seasar初期化時に、Where句は作成しない。
      b. SQL実行時に、Where句は指定された条件だけの文字列をその場で動的に作成する。
      c. Select句に含める結合先TableをProgramが指定する(これを可能とした)。
      d. FKの条件は、FK先Tableに対応するDTOへの参照に対して設定する。
         (DTOには、MyTableのColumnのSetterとForeignTableのDTOへの参照しか持たない。)
    </b>
    パフォーマンスは格段に向上しました(というか普通に戻った)。
    「a」と「b」と「c」に関して、Column数やFK数の多いTableかどうかに全く影響されなくなりました。
    「d」に関して、Column数やFK数の多いTableでもCompile速度低下への影響は格段に少なくなりました。

    また、SQLは自前のFrameworkで作成するため柔軟性もUPしました。

      - Select句に含める結合先Tableの取捨選択(しかも2階層まで)。
      - Where句で利用する結合先Tableの無限階層化。
      - RichなPaging検索 (S2Pagerを完全に不要とした)
      - その他 → <a href="./tips-condition_bean.html">Tips: ConditionBean</a> をご覧下さい。

    <b>
    DBFluteは、{Consumer向けWebサイト / 大量件数の夜間バッチ}にも採用可能な
    SQL自動生成機能「ConditionBean」を提供します。
    </b>

    _/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

</pre>
</p>

<!-- document end -->
</html>
