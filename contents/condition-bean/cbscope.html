<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja" >
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<style type="text/css" title="currentStyle">
		@import "../../css/main.css";
	</style>
	<title>DBFlute</title>
</head>
<body>

<div id="header">
	<h1><a href="../../index.html">DBFlute<span>現場指向O/Rマッパ</span></a></h1>
	<a href="../../index.html" class="logo"><img src="../../image/logo-content.gif" alt="dbflute logo"/></a>
</div>
<div id="content"><!-- __content-start__ -->
	<h2>ConditionBeanのスコープ</h2>
	<h3>概要</h3>
	<p>
		DBFluteは、DBアクセスの大きな２つのやり方を提供しています。それはConditionBeanと外だしSQL(OutsideSql)です。これら２つの存在意義に関してはここでは割愛させて頂き、いざ実装するときにこの２つのどちらを利用すれば良いのかに焦点を当てます。
	</p>
	<p>
		当然、「ConditionBeanでできないことは外だしSQLで」という正論に間違いはありませんが、
		プログラマがConditionBeanの全ての機能を頭の中で抑えていることはなかなかないかと思われます。
		そこで、素早く判断するための「判断の流れ」を紹介したいと思います。
	</p>
	<h3>A. 明らかな外だしSQLか否かを判断</h3>
	<p>
		ConditionBeanのスコープを確認する前に、まずは「明らかに外だしSQLでやるべき」と言えるものを確認していきます。
		こうすることで、ConditionBeanを意識する前の早い段階で判断が可能です。
	</p>
	<p>
		以下はConditionBeanでは実現できないことが確定しているものです。
	</p>
	<ul>
		<li>集計結果を取得する {Group By句}</li>
		<li>独自の計算をする {max(),min(),sum(),avg(),count()以外の関数}</li>
		<li>テーブル構造を更新する {DDL文}</li>
		<li>テーブルデータを問答無用削除 {Truncate}</li>
		<li>テーブル同士をマージする {Merge}</li>
		<li>(FK制約などで)関連の全くないテーブル同士での結合</li>
		<li>別テーブル同士でのUNIONもしくはUNION ALL</li>
	</ul>
	<p>
		目的(やりたいこと)が明確であることが前提です。そのDBアクセス要件がどういう結果を欲しているのかをSQL(という手段)にとらわれず考えることが大事です。
		もし、やりたいことが「テーブル検索の結果セットに子テーブル導出カラムを追加したい」であれば、
		Group By句を使っても実現はできますが(インラインビュー内でGroup Byを利用)、実はSelect句での相関サブクエリでも実現でき、
		しかも、(状況次第ではありますが)後者の方がパフォーマンスに相性も良く、ConditionBeanの「(Specify)DerivedReferrer」機能で実装することができます。
		「Group Byという手段」が頭の中で先行しているとこれを見落としてしまう可能性があります。これはDBFluteでなくても(普通にSQLを書く上で)不利益なことです。
		まず目的(やりたいこと)を明確にしてから、それを実現する(最適な)手段が上記のものかどうかを判断して下さい。
	</p>
	<h3>B. ConditionBeanのスコープを判断</h3>
	<p>
		そして、ConditionBeanのスコープからConditionBeanで実装できるか確認していきます。
	</p>
	<p>
		「明らかな外だしSQL」を通り過ぎたこの時点ではConditionBeanで実装可能である可能性が高いです。
		実際にConditionBeanを実装しながらの確認でも構いません。後に「やはり外だしSQLで実装」となっても、
		そのConditionBeanの実装は無駄にはなりません。それは「C」において後述しますが、
		近いところまで実装したConditionBeanから外だしSQLの土台となるSQLが生成できるからです。
	</p>
	<p>
		以下がConditionBeanのスコープです。
	</p>
	<h4>Select句</h4>
	<ul>
		<li>
			取得するカラムは、基本的に「基点テーブルの全てのカラム」と「指定された関連テーブルの全てのカラム」
			<ul>
				<li>取得するカラムを明示的に指定することも可能 {SpecifyColumn}</li>
				<li>「select count(*)」も可能 {SelectCount}</li>
				<li>基点テーブルのカラムの「max(),min(),sum(),avg()」も可能 {ScalarSelect}</li>
				<li>子テーブルの指定されたカラムの「max(),min(),sum(),avg(),count()」も可能 {(Speficy)DerivedReferrer}</li>
				<li>指定できる関連テーブルに関してはFrom句の欄を参照</li>
			</ul>
		</li>
	</ul>
	<h4>From句</h4>
	<ul>
		<li>結合の指定はSelect句とWhere句の指定から全て自動で判別されるので明示的に指定する必要はない</li>
		<li>結合できる関連テーブルは無限階層まで可能</li>
		<li>
			結合可能な関連テーブルはmany-to-oneもしくはone-to-oneの関係とテーブルのみ
			<ul>
				<li>親テーブル(many-to-one) → ex) 会員ステータス(MEMBER_STATUS)</li>
				<li>one-to-oneの子テーブル → ex) 会員退会情報(MEMBER_WITHDRAWAL)</li>
				<li>AdditionalForeignKeyのFixedConditionでone-to-oneに調整できる子テーブル → ex) 会員住所情報(MEMBER_ADDRESS)</li>
			</ul>
		</li>
		<li>
			結合方法は全てleft outer join限定
			<ul>
				<li>inner joinと同等の絞込みはInScopeSubQueryで代替可能</li>
			</ul>
		</li>
		<li>
			結合先だけを絞り込む(結合前に絞り込む)
			<ul>
				<li>left outer joinのon句での絞り込み</li>
				<li>インラインビューでの絞り込み</li>
			</ul>
		</li>
	</ul>
	<h4>Where句</h4>
	<ul>
		<li>
			複数条件の連結は全てAnd条件
			<ul>
				<li>Or句はUnionで代替可能 {Unionの詳細はUnion句の欄を参照}</li>
			</ul>
		</li>
		<li>
			Where句条件で以下が利用可能
			<ul>
				<li>基本演算子 {=, !=, &gt;, &gt;=, &lt;, &lt;=}</li>
				<li>InScope {in ('a', 'b')}</li>
				<li>NotInScope {not in ('a', 'b')}</li>
				<li>Like条件(前方/後方/中間)とエスケープ {like 'S%' escape '|'}</li>
				<li>IsNull / IsNotNull {is null / is not null}</li>
			</ul>
		</li>
		<li>
			結合先カラムでの絞り込み
		</li>
		<li>
			定型的なサブクエリを使った条件
			<ul>
				<li>子テーブルの条件で絞込み {InScopeSubQuery/ExistsSubQuery}</li>
				<li>子テーブル導出カラムで絞込み {(Query)DerivedReferrer}</li>
				<li>基点テーブル導出カラムで絞込み {ScalarSubQuery}</li>
			</ul>
		</li>
	</ul>
	<h4>OrderBy句</h4>
	<ul>
		<li>昇順ソート/降順ソート</li>
		<li>複数カラムのソート</li>
		<li>結合先カラムでのソート条件</li>
		<li>Null値を先にするか後にするかの指定 {NullsFirst/Last}</li>
	</ul>
	<h4>Union句</h4>
	<ul>
		<li>
			基点テーブル同士でのUnion
    		<ul>
    			<li>UnionAllも可能</li>
    			<li>Unionの数は無限</li>
    		</ul>
		</li>
	</ul>
	<h4>その他</h4>
	<ul>
		<li>ページング検索
			<ul>
				<li>各データベース固有のページング絞り込み条件を利用</li>
				<li>DB2とSQLServerはOffset処理だけResultSet読み飛ばし</li>
			</ul>
		</li>
		<li>カーソル検索
			<ul>
				<li>コールバックを指定して一件ずつフェッチしながら処理</li>
				<li>マッピングコストを省略したい場合は<a href="../outside-sql/cursor.html">外だしSQLカーソル検索</a></li>
			</ul>
		</li>
		<li>更新ロック</li>
		<li>
			子テーブルをone-to-manyの関係のまま取得 {Behavior.LoadReferrer}
			<ul>
				<li>Batchフェッチで実現(別途SQL一発で関連した子テーブルのレコードを全て取得)</li>
				<li>子テーブルの絞り込み条件やソート条件はConditionBeanで使えるものと同様</li>
				<li>{1:n:n}というように無限階層そして枝分かれ階層のLoadが可能</li>
			</ul>
		</li>
		<li>
			様々なロック
			<ul>
				<li>DB2の「with RR」や「with CS」などの細かいロック指定は、DBFluteプロパティの設定次第で利用可能</li>
			</ul>
		</li>
	</ul>
	<h3>C. やはり外だしSQLであると判断</h3>	
	<p>
		ここまで来たら、やはり「外だしSQLで」ということになります。
	</p>
	<p>
		ここで、ちょっとした「外だしSQL」の実装支援を紹介します。
		もし、この時点でConditionBeanで近いところまで実装済みであれば、それは消してはいけません。
		以下の手順が可能だからです。
	</p>
	<ol>
		<li>ConditionBeanでできるところまでテスト実装</li>
		<li>ConditionBeanのtoDisplaySql()の戻り値をログに出力</li>
		<li>ログ出力されたSQL文を外だしSQLの土台として活用</li>
	</ol>
	<p>
		このようにすることで、外だしSQLの実装にてSQLの構文やテーブル名、カラム名を一から書く必要はなくなり、
		スペルミスなどのケアレスミスもなくなります。また、判断の流れの中で実装したConditionBeanは全く無駄になりません。
	</p>
	
<!-- __content-end__ --></div>

<div id="sideBar">
	<h3>Document</h3>
	<ul>
		<li><a href="../introduction/basic.html">DBFlute Introduction</a></li>
		<ul>
			<li><a href="../introduction/tutorial4architect.html">Tutorial(for Arct)</a></li>
			<li><a href="../introduction/tutorial4developer.html">Tutorial(for Dev)</a></li>
		</ul>
		<li><a href="../setup/basic.html">DBFlute Setup</a></li>
		<ul>
			<li><a href="../setup/bytemplate.html">Template Setup</a></li>
			<li><a href="../setup/byemecha.html">EMecha Setup</a></li>
			<li><a href="../setup/versionup.html">DBFlute Upgrade</a></li>
		</ul>
		<li><a href="../maven/basic.html">Maven</a></li>
		<ul>
			<li><a href="../maven/usage.html">Usage</a></li>
		</ul>
		<li><a href="../dbvendor/basic.html">DB-Vendor Handling</a></li>
		<li><a href="../behavior/basic.html">Behavior</a></li>
		<li><a href="../entity/basic.html">Entity</a></li>
		<li><a href="../condition-bean/basic.html">ConditionBean</a></li>
		<ul>
			<li><a href="../condition-bean/cbscope.html">ConditionBean Scope</a></li>
			<li><a href="../condition-bean/cbredic.html">Reverse Dictionary</a></li>
		</ul>
		<li><a href="../outside-sql/basic.html">OutsideSql</a></li>
		<ul>
			<li><a href="../outside-sql/about.html">About OutsideSql</a></li>
			<li><a href="../outside-sql/pmcomment.html">Parameter Comment</a></li>
			<li><a href="../outside-sql/sql2entity.html">Sql2Entity</a></li>
			<li><a href="../outside-sql/entity.html">Entity Handling</a></li>
			<li><a href="../outside-sql/cursor.html">Cursor Handling</a></li>
			<li><a href="../outside-sql/dynamic.html">Dynamic Binding</a></li>
			<li><a href="../outside-sql/paging.html">Paging</a></li>
			<li><a href="../outside-sql/likesearch.html">Like Search</a></li>
		</ul>
	</ul>
	<h3>Topics</h3>
	<ul>
		<li><a href="../topic/csharpusers.html">To C# Users</a></li>
		<li><a href="../topic/withburi.html">With Buri</a></li>
		<li><a href="../maven/sastruts.html">With SAStruts</a></li>
		<li><a href="../topic/withymir.html">With Ymir</a></li>
		<li><a href="../topic/compwiths2dao.html">S2Dao Comparing</a></li>
	</ul>
</div>

<div id="footer">
<!-- 
	<ul>
		<li><a href="./sample.html">seasar</a></li>
		<li><a href="./sample.html">s2dao</a></li>
		<li><a href="./sample.html">teeda</a></li>
	</ul>
	 -->
</div>

</body>
</html>