<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja" >
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<!--  todo keywordsなど -->
	<style type="text/css" title="currentStyle">
		@import "../../css/main.css";
	</style>
	<title>DBFlute</title>
</head>
<body>

<div id="header">
	<h1><a href="../base/index.html">DBFlute</a></h1>
	<div>
		<ul>
			<li><a href="../../ja/index.html">home</a></li>
			<li><a href="../../ja/index.html#document">document</a></li>
			<!-- <li><a href="../base/index.html#document" class="active">document</a></li> -->
			<li><a href="../../ja/index.html#download">download</a></li>
			<li><a href="../../ja/index.html#tracking">bts</a></li>
		</ul>
	</div>
</div>
<div id="content"><!-- __content-start__ -->
	<h2>ConditionBeanのスコープ</h2>
	<h3>概要</h3>
	<p>
		DBFluteは、DBアクセスの大きな２つのやり方を提供しています。それはConditionBeanと外だしSQL(OutsideSql)です。これら２つの存在意義に関してはここでは割愛させて頂き、いざ実装するときにこの２つのどちらを利用すれば良いのかに焦点を当てます。
	</p>
	<p>
		当然、「ConditionBeanでできないことは外だしSQLで」という正論に間違いはありませんが、プログラマがConditionBeanの機能を頭の中で全て抑えていることは少ないと思われます。そこで、素早く判断するための「判断の流れ」を紹介したいと思います。
	</p>
	<h3>判断の流れ</h3>
	<h4>A. 明らかな外だしSQLか否かを判断</h4>
	<p>
		ConditionBeanのスコープを確認する前に、まずは「明らかに外だしSQLでやるべき」と言えるものを確認していきます。こうすることで、ConditionBeanを意識する前の早い段階で判断が可能です。
	</p>
	<p>
		以下に当てはまるものは確実に外だしSQLです。
	</p>
	<ul>
		<li>Group By句を使う</li>
		<li>SQL関数を使う(select count(*)は除く)</li>
		<li>Select句でサブクエリを使う</li>
		<li>異なるテーブル間でのUnion/Union Allを使う</li>
		<li>Merge構文やMinus構文などを使う</li>
		<li>更新ロック以外のロック指定(DB2の「with RR」やMySQLの「lock table」など)</li>
		<li>不要なカラムを徹底して省きたいなど(１ミリ秒でも稼ぎたい場合)</li>
		<li>
			カーソルで１レコードずつメモリ展開して処理したい
			<ul>
				<li>この場合はOutsideSqlのカーソル検索を利用</li>
				<li>カーソル検索については<a href="../outside-sql/cursor.html">こちら</a></li>
			</ul>
		</li>
	</ul>
	<h4>B. ConditionBeanのスコープを判断</h4>
	<p>
		そして、ConditionBeanのスコープからConditionBeanで実装できるか確認していきます。
	</p>
	<p>
		「明らかな外だしSQL」を通り過ぎたこの時点ではConditionBeanで実装可能である可能性が高いです。実際にConditionBeanを実装しながらの確認でも構いません。後に「やはり外だしSQLで実装」となっても、そのConditionBeanの実装は無駄にはなりません。それは「C」において後述しますが、近いところまで実装したConditionBeanから外だしSQLの土台となるSQLが生成できるからです。
	</p>
	<p>
		以下がConditionBeanのスコープです。
	</p>
	<h5>Select句</h5>
	<ul>
		<li>
			取得するカラムは基本的に基点テーブルの全てのカラムとSetupSelect指定されたテーブルの全てのカラム
			<ul>
				<li>取得するカラムを基点テーブルの主キーだけに絞ることも可能</li>
				<li>「select count(*)」も可能</li>
			</ul>
		</li>
    	<li>
    		結合先カラムの値を取得
    		<ul>
				<li>設定できる結合先は無限階層</li>
				<li>どんなテーブルが結合先となりうるかはFrom句の欄を参照</li>
    		</ul>
    	</li>
	</ul>
	<h5>From句</h5>
	<ul>
		<li>
			結合先はManyToOne/OneToOneの関係になるテーブルのみ
			<ul>
				<li>親テーブル(ManyToOne)
					<ul>→ ex) 会員ステータス(MEMBER_STATUS)</ul>
				</li>
				<li>OneToOneの子テーブル
					<ul>→ ex) 会員退会情報(MEMBER_WITHDRAWAL)</ul>
				</li>
				<li>AdditionalForeignKeyのFixedConditionでOneToOneに調整できる子テーブル
					<ul>→ ex) 最終ログイン(MEMBER_LOGIN)</ul>
				</li>
				※「ex」は会員(MEMBER)が基点であることを前提としています。
			</ul>
		</li>
		<li>結合の指定はSelect句とWhere句の指定から全て自動で判別されるので明示的に指定する必要はない</li>
		<li>
			結合方法は全てleft outer join限定
			<ul>
				<li>inner joinはできないが「where 基点FK is not null」という条件を組み立てることで代替は可能</li>
			</ul>
		</li>
		<li>
			結合先だけを絞り込む(結合前に絞り込む)のサブクエリ(インラインビュー)
			<ul>
				<li>サブクエリ内で利用できる絞り込み条件の仕様はConditionBeanで使えるものと同様</li>
			</ul>
		</li>
	</ul>
	<h5>Where句</h5>
	<ul>
		<li>
			複数条件の連結は全てAnd条件
			<ul>
				<li>Or句はUnionを利用することにより実現可能 {Unionの詳細はUnion句の欄を参照}</li>
			</ul>
		</li>
		<li>
			Where句条件で以下が利用可能
			<ul>
				<li>基本演算子 {=, !=, &gt;, &gt;=, &lt;, &lt;=}</li>
				<li>InScope {in ('a', 'b')}</li>
				<li>NotInScope {not in ('a', 'b')}</li>
				<li>Like条件(前方/後方/中間)とエスケープ {like 'S%' escape '|'} ※但しC#版はEscapeなし前方一致のみ(2008年1月現在)</li>
				<li>IsNull / IsNotNull {is null / is not null}</li>
			</ul>
		</li>
		<li>
			結合先カラムでの絞り込み条件(order byも含む)
    		<ul>
    			<li>設定できる結合先は無限階層</li>
				<li>どんなテーブルが結合先となりうるかはFrom句の欄を参照</li>
    		</ul>
		</li>
		<li>
			定型的なサブクエリを使った条件
			<ul>
				<li>親テーブル(結合可能テーブル)のInScopeSubQuery {基点FK in (select 親PK from 親 where ...)}</li>
				<li>子テーブルのInScopeSubQuery {基点PK in (select 子FK from 子 where ...)}</li>
				<li>子テーブルのExistsSubQuery {exists (select 子PK from 子 where 子FK = 基点PK and ...)}</li>
				<li>サブクエリ内で利用できる絞り込み条件の仕様はConditionBeanで使えるものと同様</li>
			</ul>
		</li>
	</ul>
	<h5>OrderBy句</h5>
	<ul>
		<li>昇順ソート/降順ソート</li>
		<li>複数カラムのソート</li>
		<li>
			結合先カラムでのソート条件
    		<ul>
    			<li>設定できる結合先は無限階層</li>
    			<li>昇順/降順/複数カラム指定可能</li>
    		</ul>
		</li>
	</ul>
	<h5>Union句</h5>
	<ul>
		<li>
			基点テーブル同士でのUnion {但しC#版は不可(2008年1月現在)}
    		<ul>
    			<li>UnionAllも可能</li>
    			<li>Unionの数は無限</li>
    		</ul>
		</li>
	</ul>
	<h5>その他</h5>
	<ul>
		<li>ページング検索</li>
		<li>更新ロック</li>
		<li>
			子テーブルをOneToManyの関係のまま取得 {BehaviorのLoadReferrer}
			<ul>
				<li>SubSelectフェッチになる(別SQL１発で関連している子テーブルのレコードを全て取得)</li>
				<li>子テーブルの絞り込み条件やソート条件はConditionBeanで使えるものと同様</li>
				<li>{1:n:n}というように無限階層そして枝分かれ階層のLoadが可能 ※但しC#版は不可(2008年1月現在)</li>
			</ul>
		</li>
	</ul>
	<h4>C. やはり外だしSQLであると判断</h4>	
	<p>
		ここまで来たら、やはり「外だしSQLで」ということになります。
	</p>
	<p>
		ここで、ちょっとした「外だしSQL」の実装支援を紹介します。	もし、この時点でConditionBeanで近いところまで実装済みであれば、それは消してはいけません。以下の手順が可能だからです。
	</p>
	<ol>
		<li>ConditionBeanでできるところまでテスト実装</li>
		<li>ConditionBeanのtoDisplaySql()の戻り値をログに出力</li>
		<li>ログ出力されたSQL文を外だしSQLの土台として活用</li>
	</ol>
	<p>
		このようにすることで、外だしSQLの実装にてSQLの構文やテーブル名、カラム名を１から書く必要はなくなり、スペルミスなどのケアレスミスもなくなります。また、判断の流れの中で実装したConditionBeanは全く無駄になりません。
	</p>
	<p>
		但し、ConditionBeanのtoDisplaySql()はDBFlute-0.6.0からの機能です。また、C#版ではまだ実装されていません(2008年1月現在)。toDisplaySql()がない場合は、toString()で代替します。
	</p>
	
<!-- __content-end__ --></div>

<div id="sideBar">
	<h3>Main Contents</h3>
	<ul>
		<li><a href="../setup/basic.html">DBFlute Setup</a></li>
		<ul>
			<li><a href="../setup/bytemplate.html">Template Setup</a></li>
			<li><a href="../setup/byemecha.html">EMecha Setup</a></li>
			<li><a href="../setup/aftersetup.html">After Setup</a></li>
			<li><a href="../setup/versionup.html">DBFlute Version-up</a></li>
		</ul>
		<li><a href="../condition-bean/basic.html">ConditionBean</a></li>
		<ul>
			<li><a href="../condition-bean/cbscope.html">ConditionBean Scope</a></li>
			<li><a href="../condition-bean/cbredic.html">Reverse Dictionary</a></li>
		</ul>
		<li><a href="../outside-sql/basic.html">OutsideSql</a></li>
		<ul>
			<li><a href="../outside-sql/about.html">About OutsideSql</a></li>
			<li><a href="../outside-sql/pmcomment.html">Parameter Comment</a></li>
			<li><a href="../outside-sql/sql2entity.html">Sql2Entity</a></li>
			<li><a href="../outside-sql/entity.html">Entity Handling</a></li>
			<li><a href="../outside-sql/cursor.html">Cursor Handling</a></li>
			<li><a href="../outside-sql/dynamic.html">Dynamic Binding</a></li>
			<li><a href="../outside-sql/paging.html">Paging</a></li>
			<li><a href="../outside-sql/likesearch.html">Like Search</a></li>
		</ul>
		<li><a href="../../ja/tips-behavior.html">Behavior</a></li>
		<li><a href="../dbvendor/basic.html">DB-Vendor Handling</a></li>
	</ul>
	<h3>Topics</h3>
	<ul>
		<li><a href="../topic/csharpusers.html">To C# Users</a></li>
	</ul>
	<h3>Various</h3>
	<ul>
		<li><a href="../various/sqllog.html">SqlLogRegistry</a></li>
	</ul>
</div>

<div id="footer">
<!-- 
	<ul>
		<li><a href="./sample.html">seasar</a></li>
		<li><a href="./sample.html">s2dao</a></li>
		<li><a href="./sample.html">teeda</a></li>
	</ul>
	 -->
</div>

</body>
</html>